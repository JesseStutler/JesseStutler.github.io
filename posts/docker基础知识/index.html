<!doctype html><html><head><title>Docker基础知识</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content="对于时下最常用的容器实现技术docker的介绍"><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><meta property="og:title" content="Docker基础知识"><meta property="og:description" content="对于时下最常用的容器实现技术docker的介绍"><meta property="og:type" content="article"><meta property="og:url" content="https://jessestutler.github.io/posts/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><meta property="og:image" content="https://jessestutler.github.io/images/docker-logo.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-07T10:56:15+08:00"><meta property="article:modified_time" content="2021-03-07T10:56:15+08:00"><meta property="og:site_name" content="My Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jessestutler.github.io/images/docker-logo.jpg"><meta name=twitter:title content="Docker基础知识"><meta name=twitter:description content="对于时下最常用的容器实现技术docker的介绍"><script src=/vendor/js/jquery.min.js></script><script src=/vendor/js/popper.min.js></script><script src=/vendor/js/bootstrap.min.js></script><script src=/vendor/js/smooth-scroll.polyfills.min.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><script src=/vendor/js/vue.min.js></script><link rel=stylesheet href=https://jessestutler.github.io/scss/journal.min.c116bc90d171283f099f173854157ec8f183f9073b93443b2c8ad82899ee9025.css integrity="sha256-wRa8kNFxKD8Jnxc4VBV+yPGD+Qc7k0Q7LIrYKJnukCU=" media=screen><link rel=stylesheet href=https://jessestutler.github.io/scss/dark-mode.min.552aae4638a84aa57cf0b195750a49ea9131d3bb621d1ed3ebc9b14b18166536.css integrity="sha256-VSquRjioSqV88LGVdQpJ6pEx07tiHR7T68mxSxgWZTY=" media=screen><script src=https://jessestutler.github.io//js/loadCSS.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons")</script><script src=https://jessestutler.github.io//js/toc-collapse.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script src=/vendor/js/md5.min.js></script><script>var gitalk=new Gitalk({clientID:'your client id',clientSecret:'your client secret',repo:'repo name',owner:'user',admin:['user'],id:md5(location.pathname),distractionFreeMode:'false'});window.onload=function(){gitalk.render('gitalk-container')}</script></head><body><div id=app><div ref=sideContainer class=side-container><a class="a-block nav-head false" href=https://jessestutler.github.io/><div class=nav-title>Jesse's Blog</div><div class=nav-subtitle>Stay Hungry,Stay Foolish.</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>归档</a>
<a class="a-block nav-link-item false" href=/categories>分类</a>
<a class="a-block nav-link-item false" href=/tags>标签</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
本站遵循 CC-BY-NC 4.0 协议</div></div><div ref=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- CATALOG -</center><ul><li><a href=#docker onclick="onNavClick(`#docker-nav`)" id=docker-nav>Docker</a></li><ul class=collapse data-toggle=collapse><li><a href=#docker%e6%8b%89%e5%8f%96%e9%95%9c%e5%83%8f%e6%b5%81%e7%a8%8b%e5%9b%be onclick="onNavClick(`#docker拉取镜像流程图-nav`)" id=docker拉取镜像流程图-nav>Docker拉取镜像流程图</a></li><li><a href=#docker-cli onclick="onNavClick(`#docker-cli-nav`)" id=docker-cli-nav>Docker CLI</a></li><ul class=collapse data-toggle=collapse><li><a href=#%e9%95%9c%e5%83%8f%e5%91%bd%e4%bb%a4 onclick="onNavClick(`#镜像命令-nav`)" id=镜像命令-nav>镜像命令</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e5%91%bd%e4%bb%a4 onclick="onNavClick(`#容器命令-nav`)" id=容器命令-nav>容器命令</a></li><li><a href=#%e5%8d%b7%e5%91%bd%e4%bb%a4 onclick="onNavClick(`#卷命令-nav`)" id=卷命令-nav>卷命令</a></li></ul><li><a href=#docker%e5%9f%ba%e6%9c%ac%e5%91%bd%e4%bb%a4%e5%9b%be onclick="onNavClick(`#docker基本命令图-nav`)" id=docker基本命令图-nav>Docker基本命令图</a></li><li><a href=#docker%e5%b1%82%e7%9a%84%e6%a6%82%e5%bf%b5 onclick="onNavClick(`#docker层的概念-nav`)" id=docker层的概念-nav>Docker层的概念</a></li><li><a href=#dockerfile%e5%91%bd%e4%bb%a4 onclick="onNavClick(`#dockerfile命令-nav`)" id=dockerfile命令-nav>Dockerfile命令</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e7%bd%91%e7%bb%9c%e9%85%8d%e7%bd%ae onclick="onNavClick(`#容器网络配置-nav`)" id=容器网络配置-nav>容器网络配置</a></li></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a>
<a class=pagination-action v-on:click=toggleDarkMode><i class="material-icons pagination-action-icon" v-if=isDarkMode>brightness_4</i>
<i class="material-icons pagination-action-icon" v-else=isDarkMode>brightness_7</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>归档</a>
<a class="a-block drawer-menu-item false" href=/categories>分类</a>
<a class="a-block drawer-menu-item false" href=/tags>标签</a><div class=toc><div class=toc-content><center>- CATALOG -</center><ul><li><a href=#docker onclick="onNavClick(`#docker-nav`)" id=docker-nav>Docker</a></li><ul class=collapse data-toggle=collapse><li><a href=#docker%e6%8b%89%e5%8f%96%e9%95%9c%e5%83%8f%e6%b5%81%e7%a8%8b%e5%9b%be onclick="onNavClick(`#docker拉取镜像流程图-nav`)" id=docker拉取镜像流程图-nav>Docker拉取镜像流程图</a></li><li><a href=#docker-cli onclick="onNavClick(`#docker-cli-nav`)" id=docker-cli-nav>Docker CLI</a></li><ul class=collapse data-toggle=collapse><li><a href=#%e9%95%9c%e5%83%8f%e5%91%bd%e4%bb%a4 onclick="onNavClick(`#镜像命令-nav`)" id=镜像命令-nav>镜像命令</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e5%91%bd%e4%bb%a4 onclick="onNavClick(`#容器命令-nav`)" id=容器命令-nav>容器命令</a></li><li><a href=#%e5%8d%b7%e5%91%bd%e4%bb%a4 onclick="onNavClick(`#卷命令-nav`)" id=卷命令-nav>卷命令</a></li></ul><li><a href=#docker%e5%9f%ba%e6%9c%ac%e5%91%bd%e4%bb%a4%e5%9b%be onclick="onNavClick(`#docker基本命令图-nav`)" id=docker基本命令图-nav>Docker基本命令图</a></li><li><a href=#docker%e5%b1%82%e7%9a%84%e6%a6%82%e5%bf%b5 onclick="onNavClick(`#docker层的概念-nav`)" id=docker层的概念-nav>Docker层的概念</a></li><li><a href=#dockerfile%e5%91%bd%e4%bb%a4 onclick="onNavClick(`#dockerfile命令-nav`)" id=dockerfile命令-nav>Dockerfile命令</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e7%bd%91%e7%bb%9c%e9%85%8d%e7%bd%ae onclick="onNavClick(`#容器网络配置-nav`)" id=容器网络配置-nav>容器网络配置</a></li></ul></div></div></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=https://jessestutler.github.io/>Jesse's Blog</a>
<button type=button class=nav-darkmode-toggle v-on:click=toggleDarkMode>
<i class=material-icons v-if=isDarkMode>brightness_4</i>
<i class=material-icons v-else=isDarkMode>brightness_7</i></button></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://jessestutler.github.io/><div class=single-column-header-title>Jesse's Blog</div><div class=single-column-header-subtitle>Stay Hungry,Stay Foolish.</div></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper style=background-image:url(https://jessestutler.github.io/images/docker-logo.jpg)><div class=post-title>Docker基础知识<div class=post-subtitle>对于时下最常用的容器实现技术docker的介绍</div><div class=post-meta><time itemprop=datePublished>2021-03-07 10:56</time>
<i class=material-icons>folder</i>
<a href=/categories/docker>docker</a>
&nbsp;
<i class=material-icons>label</i>
<a href=/tags/docker>docker</a>
&nbsp;</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><h1 id=docker>Docker</h1><h2 id=docker拉取镜像流程图>Docker拉取镜像流程图</h2><p><img src=https://tva1.sinaimg.cn/large/008eGmZEgy1gob5syundsj318o0ogn1v.jpg alt="截屏2020-08-12 上午10.33.14"></p><h2 id=docker-cli>Docker CLI</h2><h3 id=镜像命令>镜像命令</h3><ul><li><p><code>docker images 查看本地的镜像</code></p><p>docker images [image-name[:tag]]
默认不加参数就是-a，或者指定image的名字，可在image之上再加版本号
&ndash;a 列出所有镜像
&ndash;q [image] 列出镜像的id（-aq是列出所有的镜像id）</p></li><li><p><code>docker search 镜像</code></p><p>搜索远程仓库镜像（docker hub上查看更详细）</p></li><li><p><code>docker rmi [repo[:tag]]</code></p><p>删除本地镜像，使用方法与images相同，注意rmi是删除镜像，rm是删除容器</p><p>或者根据docker images -q [image]列出的id进行删除</p></li><li><p><code>docker tag source_image[:tag] target_image[:tag]</code></p><p>改镜像标签名（不然默认传到docker hub上的library仓库会被拒绝）</p></li><li><p><code>docker pull 镜像</code></p><p>默认拉取的是docker hub上的Image，也可以用一个容器跑一个local docker registry，然后让其他使用了docker pull并指定了docker registry地址和端口的机子从这台运行了docker registry的机子上拉镜像</p></li><li><p><code>docker push 镜像</code></p><p>将镜像上传到docker hub上的仓库或指定仓库</p></li><li><p><code>docker save -o [tar文件名] [镜像名]</code></p><p>用来将镜像保存到tar文件当中，可以指定一个或多个镜像名
也可以使用gzip压缩tar，使用docker save [镜像名] | gzip > [xxx.tar.gz]</p></li><li><p><code>docker load -i [tar文件名或gzip等压缩格式]</code></p><p>用来读取文件形成镜像</p></li></ul><h3 id=容器命令>容器命令</h3><blockquote><p><strong>docker run 创建容器并运行</strong></p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker run [选项] 镜像名 [参数]
-it 获取stdin并运行一个伪tty(默认是/bin/bash，可在命令最后自己指定shell)
--name 为容器指定一个名字(最好加上方便些，不然就要根据container id来指示是哪个容器)
最好加上自己docker hub上的repo名，这样可以直接push到自己的repo，而不用tag再改镜像名，如 jesse/centos:tag
-d 后台运行，如果容器没有对外提供服务或运行前台程序则会立刻停止
-p 将容器内的端口与host os的端口绑定起来，如-p host_port:container_port可以通过访问host的某个端口来访问容器内的某个服务
-P 大写P,将镜像指定的暴露端口与host os上的随机端口绑定起来，一般需要Dockerfile中有EXPOSE进行结合
-v 将容器内的某个文件夹与host os的文件夹绑定起来（即数据同步，相当于挂载）
1.如-v host_dir:container_dir 指定路径挂载，可以将容器内的指定文件夹数据同步到host os的指定目录上，这样删除容器时不至于数据丢失（比如容器内装有Mysql，这样删除容器就相当于把整个数据库都删了）
2.如-v volume_name:container_dir 具名挂载，会指定卷名，可以通过docker volume inspect volume_name查看在Host os上的目录位置
--volumes-from 继承已有的容器的数据卷（共享目录）
e.g:
docker run --name centos -it centos /bin/bash
</code></pre></div><blockquote><p><strong>docker ps 查看容器</strong></p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>不指定参数就是查看正在运行的容器
-a 查看所有容器（包括停止的容器）
-q 列出容器id
</code></pre></div><blockquote><p>docker rm [container id 或者 container name] 删除容器</p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>不加参数需要指定container id或者container name，正在运行的容器无法删除
-f 强制删除容器
docker ps -aq | xargs docker rm -f 强制删除所有容器
</code></pre></div><blockquote><p>docker start 启动容器</p><p>docker restart 重启容器</p><p>docker stop 停止容器</p></blockquote><blockquote><p>docker logs 查看日志</p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>-f 实时跟随
-t 显示时间
</code></pre></div><blockquote><p>docker top 显示容器内正在运行的进程</p></blockquote><blockquote><p>docker inspect 显示容器的所有<strong>配置信息（元数据）d</strong></p></blockquote><blockquote><p><strong>进入正在运行的容器</strong></p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>1.docker <span style=color:#658b00>exec</span> [container] [command]
在容器里跑一个命令
-it 与docker run相同，获取stdin并进入伪tty
e.g:
docker <span style=color:#658b00>exec</span> -it [container id或者container name] bash ———— 在容器里跑一个新的bash并进入

2.docker attach [container]
直接进入到container当中
</code></pre></div><blockquote><p>docker cp 将容器中的文件拷贝到外部os或将外部os的文件拷贝至容器中</p></blockquote><p><code>docker cp container:path dest_path</code></p><blockquote><p>docker commit 由现有容器制作镜像</p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>-a 指定作者名
-m 这次提交要发布的消息
docker commit [选项] container [image[:tag]]
</code></pre></div><h3 id=卷命令>卷命令</h3><blockquote><p>docker volume</p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>特别说明：不同的容器可以指定相同的volume
ls 列出所有的卷
inspect 查看指定卷的信息（可查看挂载在host os上具体哪个位置）
</code></pre></div><h2 id=docker基本命令图>Docker基本命令图</h2><p><img src=https://tva1.sinaimg.cn/large/008eGmZEgy1gob60cd4z5j316t0u0k9j.jpg alt=image-20200812163714285></p><h2 id=docker层的概念>Docker层的概念</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1597383379693&di=8a718adcadd59dbfafaf89136bcf6efe&imgtype=0&src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F2030366%2F202006%2F2030366-20200630103737429-2119801149.png" alt=img></p><h2 id=dockerfile命令>Dockerfile命令</h2><p>tips:</p><ul><li><p>命令最好大写，写一个命令代表构建</p></li><li><p>选用合适的镜像，不要选用过大的父镜像从而构建出臃肿庞大的镜像，选用小巧的父镜像（如alpine、busybox、debian等）</p></li><li><p><strong>使用多阶段构建形式（多个FROM命令，以最后一个FROM为根），例如将编译环境和构建环境分离开来可以避免镜像过大（因为构建环境只需要编译出来的可执行文件，而不需要编译所需的库和命令等一大堆文件）</strong></p><p>COPY &ndash;from=指定的阶段名</p><p>可以将指定阶段中编译好的文件拷贝到当前构建环境中，甚至可以从指定镜像中进行拷贝</p><p>e.g:</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#228b22># 编译阶段 命名为 builder</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#8b008b;font-weight:700>FROM</span><span style=color:#cd5555> golang:1.10.3 as builder</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#228b22># ... 省略</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#228b22># 运行阶段</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#8b008b;font-weight:700>FROM</span><span style=color:#cd5555> scratch</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#228b22># 从编译阶段的中拷贝编译结果到当前镜像中</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#8b008b;font-weight:700>COPY</span> --from=builder /build/server /<span style=color:#a61717;background-color:#e3d2d2>
</span></code></pre></div></li></ul><blockquote><p><strong>docker build</strong> 根据Dockerfile构建镜像命令</p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker build [选项] URL|PATH
-f 要用哪一个Dockerfile（指定Path）
-t 给镜像取名字，可加tag（name:tag）
e.g:
docker build -f Dockerfile -t name:tag . 将当前的文件夹作为环境构造镜像
可以以PATH指定的目录作为上下文环境来构建镜像，最好是以空目录为上下文环境，里面只放Dockerfile（除非是放生成镜像必须的文件，因为上下文过大的话发送给daemon会很慢），也可以是指定URL作为构建环境，也就是Git Repository，比如Github
</code></pre></div><blockquote><p><strong>FROM</strong></p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#8b008b;font-weight:700>FROM</span><span style=color:#cd5555> image</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span>Dockerfile都要以FROM开始，构建一个基本镜像<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span>e.g:<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#8b008b;font-weight:700>FROM</span><span style=color:#cd5555> scratch</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span>这是Docker Hub上大多数镜像的选择，构建一个默认镜像<span style=color:#a61717;background-color:#e3d2d2>
</span></code></pre></div><blockquote><p><strong>RUN</strong></p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#8b008b;font-weight:700>RUN</span> shell_command<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span>build镜像时所要执行的命令<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span>一般以执行shell命令的格式最佳,默认是以RUN /bin/sh -c command形式执行的<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span>一行写不下时可以通过<span style=color:#cd5555>\换</span>行,执行多个命令最好用&amp;&amp;来相连，这样可以少些一些RUN，因为RUN、ADD、COPY这些命令写一个命令就会加一层，这样会使容器不那么臃肿庞大<span style=color:#a61717;background-color:#e3d2d2>
</span></code></pre></div><blockquote><p>CMD</p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#8b008b;font-weight:700>CMD</span> [<span style=color:#cd5555>&#34;executable&#34;</span>,<span style=color:#cd5555>&#34;param1&#34;</span>,<span style=color:#cd5555>&#34;param2&#34;</span>]一般以这种格式最佳（注意都要双引号，因为是JSON格式）<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#8b008b;font-weight:700>CMD</span>是容器运行时所要执行的命令，旨在指定run容器时所要做的默认动作，跟docker run后跟一个command原理是一样的<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span>特别说明：Dockerfile中只能有一个CMD,如果有多个CMD，只有最后一个生效<span style=color:#a61717;background-color:#e3d2d2>
</span></code></pre></div><blockquote><p>ENTRYPOINT</p></blockquote><pre><code>使用方法与CMD相同，但是docker run后面如果跟command会把CMD要执行的命令覆盖掉，ENTRYPOINT要执行的命令不会，甚至能给ENTRYPOINT追加参数
</code></pre><blockquote><p>LABEL</p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#8b008b;font-weight:700>LABEL</span> <span style=color:#00688b>key</span>=<span style=color:#cd5555>&#34;value&#34;</span> <span style=color:#00688b>key</span>=<span style=color:#cd5555>&#34;value&#34;</span> ... <span style=color:#00688b>key</span>=<span style=color:#cd5555>&#34;value&#34;</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span>给镜像加元数据，以键值对的形式多组追加，可以通过<span style=color:#cd5555>\换</span>行,比如在LABEL里加上maintainer（维护者）等信息<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span>可以通过docker inspect来查看<span style=color:#a61717;background-color:#e3d2d2>
</span></code></pre></div><blockquote><p>EXPOSE</p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile>让运行时的容器在指定端口进行监听，也就是暴露端口,默认是tcp，可以指定udp，如EXPOSE 53/udp<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span>可以通过docker run中的-p来覆盖，也可以通过-P将host os上的随机端口与暴露的端口进行绑定<span style=color:#a61717;background-color:#e3d2d2>
</span></code></pre></div><blockquote><p><strong>ENV</strong></p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile>为运行的容器设置环境变量<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#8b008b;font-weight:700>ENV</span> key value 一个ENV设置一个环境变量<span style=color:#a61717;background-color:#e3d2d2>
</span></code></pre></div><blockquote><p>ADD</p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#8b008b;font-weight:700>ADD</span> &lt;src&gt;...&lt;dest&gt;<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span>将src的文件，文件夹拷贝到dest，src可以是一个remote URL，dest可以是相对路径也可以是绝对路径，如果是相对路径那就是拷贝到WORKDIR/相对路径下<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span>特别说明：dest如果是文件夹，想把文件拷贝到dest文件夹下，必须在最后加/<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#8b008b;font-weight:700>COPY</span>指令与ADD用法相同，但是ADD可以从远程url上拷贝，COPY只能拷贝本地宿主机上的文件<span style=color:#a61717;background-color:#e3d2d2>
</span></code></pre></div><blockquote><p>WORKDIR</p></blockquote><pre><code>设置进入容器时的工作目录，能使用ENV设置的环境变量
</code></pre><h2 id=容器网络配置>容器网络配置</h2><blockquote><p>docker network</p></blockquote><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>connect 将一个容器部署进某个配置的网络当中，通过ls查看网络名
ls 列出所有网络
inspect 查看网络描述信息
create 创建网络，可通过-d指定方式，有bridge，host等等，可通过--subnet指定子网和后缀
...
要让容器使用docker network创建的网络，在docker run时指定--net即可
</code></pre></div><hr width=100% id=EOF><p style=color:#777>Last modified on 2021-03-07</p></div></div><nav class=post-pagination><a class=newer-posts href=https://jessestutler.github.io/posts/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/>Next<br>Docker底层原理</a>
<a class=older-posts href=https://jessestutler.github.io/posts/kubectl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/>Previous<br>kubectl常用命令</a></nav><div class=post-comment-wrapper><div id=gitalk-container></div></div></div></div></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
本站遵循 CC-BY-NC 4.0 协议</div></div><script>let app;app=new Vue({el:'#app',data:{scrollY:0,navOpacity:0,isDrawerOpen:!1,mounted:!1,isDarkMode:!1},methods:{sgn(a,b){let c=1/(1-2*a);return b<=a?0:b>=1-a?1:c*(b-a)},handleScroll(){this.scrollY=window.scrollY,this.navOpacity=this.sgn(0,Math.min(1,Math.max(0,window.scrollY/(this.pageHeadHeight()-this.navBarHeight()*.8))));const{navBar:c,navBackground:a,navTitle:b,extraContainer:d,streamContainer:e}=this.$refs;this.navOpacity>=1?(a.style.opacity=1,b.style.opacity=1):(a.style.opacity=0,b.style.opacity=0)},handleResize(){const{navBar:c,navBackground:d,navTitle:e,extraContainer:a,streamContainer:b}=this.$refs;a.style.left=b.offsetWidth-a.offsetWidth+'px'},navBarHeight(){return this.$refs.navBar.offsetHeight},pageHeadHeight(){return this.$refs.pageHead.offsetHeight},toggleDrawer(){this.isDrawerOpen=!this.isDrawerOpen,document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset'},closeDrawer(){this.isDrawerOpen=!1,document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset'},toggleDarkMode(){this.isDarkMode=!this.isDarkMode,this.isDarkMode==!0?(document.cookie="night=1;path=/",document.body.classList.add("night")):(document.cookie="night=0;path=/",document.body.classList.remove("night"))}},created(){window.addEventListener('scroll',this.handleScroll),window.addEventListener('resize',this.handleResize),window._nonDesktop=function(){let a=!1;return function(b){(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(b)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(b.substr(0,4)))&&(a=!0)}(navigator.userAgent||navigator.vendor||window.opera),a};var a=document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/,"$1");a==""?window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches:a=="1"&&this.toggleDarkMode()},mounted(){this.handleScroll(),this.handleResize(),this.mounted=!0},destroyed(){window.removeEventListener('scroll',this.handleScroll),window.removeEventListener('resize',this.handleResize)}})</script><script src=https://jessestutler.github.io//js/journal.js></script></body></html>