<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Jesse's Blog</title><link>https://jessestutler.github.io/posts/</link><description>Recent content in Posts on Jesse's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Tue, 09 Mar 2021 16:30:52 +0800</lastBuildDate><atom:link href="https://jessestutler.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Raft</title><link>https://jessestutler.github.io/posts/raft/</link><pubDate>Tue, 09 Mar 2021 16:30:52 +0800</pubDate><guid>https://jessestutler.github.io/posts/raft/</guid><description>Raft 引言 Raft是分布式数据一致性算法，用于解决PAXOS多年来晦涩难懂且难以工程复现的问题，本文对Raft发表的原文论文进行了大致解读
基本算法内容 Basics Follower,Candidate,Leader 每个server分为三种状态（状态转换图见Leader election）：
Follower：只接受RPC请求（就算收到来自client的请求也会重定向给leader） Candidate：参加竞选，可以发送RequestVote RPC，同样也可以接受请求 Leader（only one）：只有Leader可以处理来自client的请求，可以发送AppendEntries RPC，可以是追加日志条目用，也可以是心跳检测用（定期检测其他server是否还活着，通过无条目追加的AppendEntries RPC来做到） term——任期 Raft将时间随机划分，每一段称为任期（任期是单调递增的），任期都以一次选举开始，选举可以是选出leader也可以是未能选出leader（未能选出leader就直接进入下一任期）
每台server发现自己的任期小于其他机器就需要update到最新
entry——条目 条目就是指日志的条目，由client发来的command+任期数（term number，用来检测不一致性）+index（条目索引）构成
Leader election 状态转换图分析：
Starts up:
初始时，每台server都是Follower
Follower&amp;mdash;&amp;gt;Candidate：
当超出election timeout时间（长时间未收到有Leader发过来的RPC消息，说明当前cluster未选出leader，或者是未收到来自candidate的RequestVote RPC），Follower增加自己的当前任期数，并将自己转换为Candidate；参加竞选leader，给自己投票，然后并发地向其他server发送RequestVote RPC请求，需要他们给自己进行投票（一般规则是先收到谁请求就投谁）；重设election timeout
Candidate&amp;mdash;&amp;gt;Candidate：
选举发生投票分歧 未能选出leader（发生投票分歧），比如有好几台Candidates票数一致的情况，或者大家都是Candidate（不可能给竞争对手投票是吧:P ），增加自己的当前任期数，并开始新一轮的选举。不过这样有可能造成一直产生投票分歧的情况，打破这种情况并选出leader的机制就是election timeout，Candidates从时间段中随机给自己选一个election timeout时间，如果发生投票分歧，先超时的Candidate赢得选举
Candidate收到Leader（已经暂时选出的）的RPC请求，发现其任期比自己旧，拒绝请求并保持Candidate状态 Candidate&amp;mdash;&amp;gt;Leader：
赢得竞选（获得大多数servers的投票）
Leader&amp;mdash;&amp;gt;Follower:
通过RPC的回复发现自己的任期已过期（有比自己更新的任期），退回到Follower
Candidate&amp;mdash;&amp;gt;Follower：
输掉选举（收到了来自己已选出的leader的RPC，但要确定自己的任期至少和Leader的任期相同，参考第3步） 通过RPC的回复发现自己的任期已过期（有比自己更新的任期），退回到Follower Log Replication 首先要说明的是，Leader只追加条目（entry）而不修改或删除entry</description></item><item><title>Golang基础</title><link>https://jessestutler.github.io/posts/golang%E5%9F%BA%E7%A1%80/</link><pubDate>Sun, 07 Mar 2021 11:25:55 +0800</pubDate><guid>https://jessestutler.github.io/posts/golang%E5%9F%BA%E7%A1%80/</guid><description>GOLANG 引言 云原生体系下，golang一定是必须要掌握的高级语言，golang内置的goroutine契合分布式架构的设计，越来越多的关于云的开源项目采用go进行实现。本文参考：http://c.biancheng.net/golang/intro/ ，本文对go的基础知识进行了大致介绍，可参照右侧的大纲检索，本文会持续更新。
这里笔者也推荐一些go练手项目：
https://geektutu.com/post/gee.html 极客兔兔的7天用go从零实现系列（必须强烈推荐👍，一天天打下来能对很多go的开源项目有个大致的认识，也能学到很多技巧） https://courses.calhoun.io/courses 需要挂梯子，作为一些对于go不同的包的练手项目不错 常用命令 go install [package-name]
编译并安装包，如果不是main包则会安装到pkg底下作为库包，如果是main包则会安装到bin底下作为可执行文件
go doc [package] [func]
go手册
go build [file or package]
如果是main包，生成可执行文件（可执行文件名同文件夹名），如果不是main包，不生成可执行文件，只进行编译
如果是单个.go文件，main包中只能对含main函数的go文件进行编译并生成可执行文件，其他包只进行编译
go module 以后默认用go module的方式进行包管理和添加依赖，以后workspace不必在$GOPATH下，$GOPATH就存放下载的包和编译好的课执行文件
root workspace底下有两个文件，一个是go.mod（包管理），一个是go.sum（包校验），真正的包下载好放在$GOPATH/pkg/mod底下
在root workspace底下用go mod init[模块名]生成go.mod，模块名命名格式为example.com/xxx..（一般就github.com/foo这样），然后引用workspace底下子目录的go文件，用模块名/子目录名的格式引用
给项目添加依赖（写进 go.mod)的两种方法：
你只要在项目中有 import，然后 go build 就会 go module 就会自动下载并添加（perfect way） 自己手工使用 go get 下载安装后，会自动写入 go.mod 常用命令 go mod init</description></item><item><title>Docker底层原理</title><link>https://jessestutler.github.io/posts/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</link><pubDate>Sun, 07 Mar 2021 11:12:39 +0800</pubDate><guid>https://jessestutler.github.io/posts/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</guid><description>docker底层原理 namespace——资源隔离 namespace 是 Linux 内核用来隔离内核资源的方式，同一个namespace中的进程之间可以互相感知，不同namespace之间的进程是相互独立的，docker本身就是一个进程，通过namespace来实现隔离，从而模拟独立运行环境，在/proc/$$/ns下能查看当前进程下的所有link文件，每个link文件对应不同的namespace，如果不同的进程间有相同的namespace的inode号，则他们是共享namespace的，否则他们属于不同的的namespace
**通过clone()函数在创建子进程的同时给子进程创建新的namespace（传入CLONE_*宏定义）**
UTS namespace：
提供主机名和域名的隔离，使容器能够通过服务名访问
IPC namespace（进程间通信）：
实现信号量、消息队列和共享内存等资源的隔离
PID namespace：
对进程内的PID重新标号，从1开始，每个PID namespace都有自己的计数程序，宿主机的PID namespace相当于创建进程的PID namespace的parent pid namespace，能看到子节点（child pid namespace)中的内容，但子节点不能看到父节点当中的内容，这样父节点能在外部管理容器内的进程
如果pid namespace中的某个进程的父进程被杀死，该进程成为孤儿进程，则会被当前pid namespace的init进程（pid为1，如/bin/bash）收养，成为其子进程
mount namespace:
通过隔离文件系统挂载点来隔离文件系统（当创建新的mount namespace时，会将所有挂载点复制给子进程，但在这之后，子进程对自己namespace内文件系统进行的操作不会影响到父进程namespace）
可以通过共享挂载机制传播挂载（主从挂载、共享挂载等）
network namespace:
提供网络资源的隔离，包括网络设备、协议栈、路由表、防火墙等等
默认的bridge模式：
每个容器有独立的network namespace，宿主机通过docker0网桥（虚拟网桥）来连接不同的network namespace，容器通过veth pair（虚拟以太网端口对，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来）连接docker0网桥，设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名。
如果容器想主动和外界通信，或者外界想访问容器内的服务（访问宿主机的端口），实际上这是通过iptables来管理的（进行了转发和NAT转换等操作）
host模式：
容器和宿主机共享network namespace，但其他namespace与宿主机隔离，容器用的是宿主机的ip与外界通信，性能较好但易产生端口冲突
container模式：
新创建的容器若指定container模式，则和已经存在的容器共享一个network namespace，与此容器共享ip和协议栈
user namespace
提供安全隔离，比如用户id，用户组，权限等，在子进程的user namespace中拥有新的用户和用户组，在父进程中的普通用户可能却成为子进程中namespace的超级用户，结构与pid namespace类似（树状结构），子user namespace中的用户和用户组需要与父user namespace中的用户和用户组相对应（做映射），这样这个user namespace才能与其他user namespace中的进程通信，甚至访问共享的文件（即对应到其他user namespace的用户和用户组并拥有相应的权限，如果没有相应的权限就不能在其他user namespace执行某些操作）</description></item><item><title>Docker基础知识</title><link>https://jessestutler.github.io/posts/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Sun, 07 Mar 2021 10:56:15 +0800</pubDate><guid>https://jessestutler.github.io/posts/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>Docker Docker拉取镜像流程图 Docker CLI 镜像命令 docker images 查看本地的镜像
docker images [image-name[:tag]] 默认不加参数就是-a，或者指定image的名字，可在image之上再加版本号 &amp;ndash;a 列出所有镜像 &amp;ndash;q [image] 列出镜像的id（-aq是列出所有的镜像id）
docker search 镜像
搜索远程仓库镜像（docker hub上查看更详细）
docker rmi [repo[:tag]]
删除本地镜像，使用方法与images相同，注意rmi是删除镜像，rm是删除容器
或者根据docker images -q [image]列出的id进行删除
docker tag source_image[:tag] target_image[:tag]
改镜像标签名（不然默认传到docker hub上的library仓库会被拒绝）
docker pull 镜像
默认拉取的是docker hub上的Image，也可以用一个容器跑一个local docker registry，然后让其他使用了docker pull并指定了docker registry地址和端口的机子从这台运行了docker registry的机子上拉镜像
docker push 镜像
将镜像上传到docker hub上的仓库或指定仓库
docker save -o [tar文件名] [镜像名]</description></item><item><title>kubectl常用命令</title><link>https://jessestutler.github.io/posts/kubectl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 07 Mar 2021 10:30:17 +0800</pubDate><guid>https://jessestutler.github.io/posts/kubectl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>k8s命令 引言 本文列举了一些kubectl的常用命令以及其对应的常用参数
kubectl的详细信息可参照：https://kubernetes.io/docs/reference/kubectl/overview/
如果熟悉了kubectl的朋友，对于经常性的kubectl get 和kubectl describe查找resource感到繁琐，笔者在这里推荐一款开源的增强型kubectl软件k9s：https://github.com/derailed/k9s，相信对于vim熟悉的朋友会喜欢这款开源软件，而且可以当简略的dashboard使用
kubectl kubectl create -f [yaml或者json文件]
通过yaml或者json文件创建一个组件
-n 指定命名空间，如果不指定，默认是在default命名空间下，其他命令也一样
kubectl get [组件] [组件名]
获取组件的基本信息，如果想获取详细信息用kubectl describe
-o wide 显示更多信息，-o yaml 以yaml格式显示组件信息
&amp;ndash;show-labels 多显示标签
-l 标签键=值 根据标签来筛选出pod基本信息，多个键值对用逗号分隔
-L [标签名] 多显示指定标签名的标签列，多个标签用逗号分隔
&amp;ndash;all-namespaces 列出所有命名空间的组件
kubectl logs [podname]
查看pod内容器的日志输出，如果只有一个容器不用指定容器名，如果有多个容器，想查看指定容器的日志需要-c参数指定
kubectl label [组件] [组件名] key=value [--overwrite]
修改或添加组件的标签，用key=value形式，如果要复写之前的标签，需要多加一个&amp;ndash;overwrite
如果要删除之前的标签，直接在key后跟一个减号即可（即key-）
kubectl delete [组件] [组件名1] [组件名2] [...]
删除组件
-all 删除所有组件
注：删除命名空间，里面的组件也会一并删除
kubectl scale [组件] [组件名] --replicas</description></item><item><title>K8s Resource概析</title><link>https://jessestutler.github.io/posts/k8s-resource%E6%A6%82%E6%9E%90/</link><pubDate>Sun, 07 Mar 2021 10:20:30 +0800</pubDate><guid>https://jessestutler.github.io/posts/k8s-resource%E6%A6%82%E6%9E%90/</guid><description>K8s Resource概析 引言 本文参照《Kubernetes in Action中文版》及其一些网上资料，对K8s中基础的Resource进行了概析。本文会持续更新。
pod 为什么需要pod?
主要目的是由多个进程组成的一个应用程序，多个进程不能聚集在一个容器中运行**（容器的设计目的就是只运行一个进程，如果容器中运行多个不相关的进程，比如需要包含一种进程崩溃后能够重启的机制，同时将进程的活动记录记录到相同的标准输出中，我们很难确定每个进程分别记录了什么），我们用pod来封装容器，将其作为k8s的基本单位**，既可以做到一个进程单独运行于一个容器当中，容器之间相互隔离，保持了容器的特性，又能同时运行一些密切相关的进程，为他们提供相同的环境。
pod中的容器共享network namespace，容器中运行的进程之间能够通过端口来相互通信（同一个pod中的容器拥有相同的loopback网路接口，可以通过发往localhost与其他容器中的进程相互通信）
如何决定多个容器是否要放入同一个pod中？ 它们需要一起运行还是可以在不同主机上运行 它们代表的是一个整体还是相互独立的组件 它们必须一起扩缩容还是可以分别进行 liveness probe &amp;amp; readiness probe liveness probe——存活探针（在pod running时检测）
通过 TCP、HTTP 或者命令行方式对应用就绪进行检测。对于 HTTP 类型探针，Kubernetes 会定时访问该地址，如果该地址的返回码不在 200 到 400 之间，则认为该容器不健康，会杀死该容器重建新的容器。
readiness probe——就绪探针（在pod就绪前检测）
对于启动缓慢的应用，为了避免在应用启动完成之前将流量导入。Kubernetes 支持业务容器提供一个 readiness 探针，对于 HTTP 类型探针，Kubernetes 会定时访问该地址，如果该地址的返回码不在 200 到 400 之间，则认为该容器无法对外提供服务，不会把请求调度到该容器。
容器重启策略 Always ： 容器失效时，kubelet 自动重启该容器（就算成功执行完容器也会重启） OnFailure ： 容器终止运行且退出码不为0时重启 Never ： 不论状态为何， kubelet 都不重启该容器 节点亲和性 nodeAffinity:</description></item></channel></rss>