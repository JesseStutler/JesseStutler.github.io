<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>k8s on Jesse's Blog</title><link>https://jessestutler.github.io/tags/k8s/</link><description>Recent content in k8s on Jesse's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Thu, 10 Jun 2021 14:51:48 +0800</lastBuildDate><atom:link href="https://jessestutler.github.io/tags/k8s/index.xml" rel="self" type="application/rss+xml"/><item><title>K8s Iptables分析</title><link>https://jessestutler.github.io/posts/k8s-iptables%E5%88%86%E6%9E%90/</link><pubDate>Thu, 10 Jun 2021 14:51:48 +0800</pubDate><guid>https://jessestutler.github.io/posts/k8s-iptables%E5%88%86%E6%9E%90/</guid><description>K8s iptables分析 笔者最近因为需要看了下k8s的kube-proxy在默认iptables模式下对于iptables规则是如何管理的，以此作为记录并分享，后面会继续跟进kube-proxy并进行源码分析
这里笔者分享一套还不错的iptables学习路线：
https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables
iptables知识 查 -t [表名] 指定想查看的表的规则，默认为filter表
-L [链名] 指定想查看的某个表在某个链当中的规则，不写链列出表在所有链当中的规则
-v 列出详细规则
-n 不做域名解析，直接显示ip（通常-nvL同行）
&amp;ndash;line-number 显示行数
e.g:
iptables -t nat -L INPUT
列出nat表在INPUT链中的所有规则
增 -I [链名] 插入规则到指定的链当中（在链的首部插入）
-I [链名] [序号] 插入规则到指定的链当中（指定是链的第几条规则）
-A [链名] 插入规则到指定的链当中（在链的尾部插入）
-s [源地址,[源地址]&amp;hellip;] 或[源地址网段]
-d [目标地址]
用!在-s或-d前表示取反，非地址匹配
&amp;ndash;sport 源端口
&amp;ndash;dport 目标端口
&amp;ndash;sport/dport [起始端口:结束端口] 表示匹配此范围内端口
指定源端口和目标端口为扩展匹配条件，-m用来指定扩展模块，如-m tcp -dport 22表示匹配ssh，若不指定-m（最好指定），默认与-p指定的协议相同
-m [模块] 使用模块扩展匹配条件
离散端口： -m multiport --dports 22,53,80 需要指定multiport模块用来离散匹配 范围ip： -m iprange --src-range 192.168.0.211-192.168.0.220 加备注： -m comment --comment [.</description></item><item><title>kubectl常用命令</title><link>https://jessestutler.github.io/posts/kubectl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 07 Mar 2021 10:30:17 +0800</pubDate><guid>https://jessestutler.github.io/posts/kubectl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>k8s命令 引言 本文列举了一些kubectl的常用命令以及其对应的常用参数
kubectl的详细信息可参照：https://kubernetes.io/docs/reference/kubectl/overview/
如果熟悉了kubectl的朋友，对于经常性的kubectl get 和kubectl describe查找resource感到繁琐，笔者在这里推荐一款开源的增强型kubectl软件k9s：https://github.com/derailed/k9s，相信对于vim熟悉的朋友会喜欢这款开源软件，而且可以当简略的dashboard使用
kubectl kubectl create -f [yaml或者json文件]
通过yaml或者json文件创建一个组件
-n 指定命名空间，如果不指定，默认是在default命名空间下，其他命令也一样
kubectl get [组件] [组件名]
获取组件的基本信息，如果想获取详细信息用kubectl describe
-o wide 显示更多信息，-o yaml 以yaml格式显示组件信息
&amp;ndash;show-labels 多显示标签
-l 标签键=值 根据标签来筛选出pod基本信息，多个键值对用逗号分隔
-L [标签名] 多显示指定标签名的标签列，多个标签用逗号分隔
&amp;ndash;all-namespaces 列出所有命名空间的组件
kubectl logs [podname]
查看pod内容器的日志输出，如果只有一个容器不用指定容器名，如果有多个容器，想查看指定容器的日志需要-c参数指定
kubectl label [组件] [组件名] key=value [--overwrite]
修改或添加组件的标签，用key=value形式，如果要复写之前的标签，需要多加一个&amp;ndash;overwrite
如果要删除之前的标签，直接在key后跟一个减号即可（即key-）
kubectl delete [组件] [组件名1] [组件名2] [...]
删除组件
-all 删除所有组件
注：删除命名空间，里面的组件也会一并删除
kubectl scale [组件] [组件名] --replicas
设置组件管理的资源数量，组件可以是Deployment, ReplicaSet, Replication Controller, StatefulSet or job</description></item><item><title>K8s Resource概析</title><link>https://jessestutler.github.io/posts/k8s-resource%E6%A6%82%E6%9E%90/</link><pubDate>Sun, 07 Mar 2021 10:20:30 +0800</pubDate><guid>https://jessestutler.github.io/posts/k8s-resource%E6%A6%82%E6%9E%90/</guid><description>K8s Resource概析 引言 本文参照《Kubernetes in Action中文版》及其一些网上资料，对K8s中基础的Resource进行了概析。本文会持续更新。
pod pod中的容器共享network namespace，容器中运行的进程之间能够通过端口来相互通信（同一个pod中的容器拥有相同的loopback网路接口，可以通过发往localhost与其他容器中的进程相互通信）
如何决定多个容器是否要放入同一个pod中？ 它们需要一起运行还是可以在不同主机上运行 它们代表的是一个整体还是相互独立的组件 它们必须一起扩缩容还是可以分别进行 liveness probe &amp;amp; readiness probe liveness probe——存活探针（在pod running时检测）
在容器内部执行一个命令，若该命令的退出状态码为0，则健康 通过容器的ip和端口进行TCP检查，若端口能被访问到，则容器健康 调用http get方法，若响应码在200到400之间，则健康 readiness probe——就绪探针（在pod就绪前检测）
对于启动缓慢的应用，为了避免在应用启动完成之前将流量导入。Kubernetes 支持业务容器提供一个 readiness 探针，探测规则同存活探针
容器重启策略 Always ： 容器失效时，kubelet 自动重启该容器（就算成功执行完容器也会重启） OnFailure ： 容器终止运行且退出码不为0时重启 Never ： 不论状态为何， kubelet 都不重启该容器 节点亲和性 nodeAffinity:
约束pod可以调度到哪些节点，是对nodeSelector的一种加强。有以下两种字段：
requiredDuringSchedulingIgnoredDuringExecution（硬限制）：
表示node必须满足pod指定条件(matchExpression）才能将pod调度到这些节点上，否则不进行调度（与nodeSelector相同）
preferredDuringSchedulingIgnoredDuringExecution（软限制）：
偏好将pod调度到满足pod指定条件的node上，如果没有满足指定条件的节点没关系，还是可以将pod调度到其他节点上
IgnoredDuringExecution表示纵使节点标签发生改变，pod仍可以在节点上继续运行
pod间亲和性 如果是大集群不建议使用pod亲和，否则需要涉及到大量的处理
podAffinity和podAntiAffinity（pod亲和和反亲和）:
既需要node匹配，又需要pod匹配，他的规则是：如果 X 节点上已经运行了一个或多个 满足规则 Y 的pod，则这个 pod 应该（或者在非亲和的情况下不应该）运行在 X 节点，X和Y都是标签（X是node的标签，可以是k8s内置标签也可以是自定义标签，表示一个拓扑域，Y是pod标签）
字段与nodeAffinity相同，需要在pod的Spec中写明
污点和容忍度 污点其实就是节点的反亲和性，用处在于某些pod需要调度到特定节点上，而其他pod不能调度到这些节点上（就需要给pod加上容忍度），或者是某些节点挂掉了，需要驱逐某些pod，或者加上容忍度，容忍在指定时间内节点可以恢复，否则就要被驱逐
使用 kubectl taint nodes node1 key=value:NoSchedule命令给node加上taint，用法类似kubectl label，要说明的是NoSchedule，有以下几种动作：</description></item></channel></rss>