<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>docker on Jesse's Blog</title><link>https://jessestutler.github.io/tags/docker/</link><description>Recent content in docker on Jesse's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Sun, 07 Mar 2021 11:12:39 +0800</lastBuildDate><atom:link href="https://jessestutler.github.io/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker底层原理</title><link>https://jessestutler.github.io/posts/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</link><pubDate>Sun, 07 Mar 2021 11:12:39 +0800</pubDate><guid>https://jessestutler.github.io/posts/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</guid><description>docker底层原理 namespace——资源隔离 namespace 是 Linux 内核用来隔离内核资源的方式，同一个namespace中的进程之间可以互相感知，不同namespace之间的进程是相互独立的，docker本身就是一个进程，通过namespace来实现隔离，从而模拟独立运行环境，在/proc/$$/ns下能查看当前进程下的所有link文件，每个link文件对应不同的namespace，如果不同的进程间有相同的namespace的inode号，则他们是共享namespace的，否则他们属于不同的的namespace
**通过clone()函数在创建子进程的同时给子进程创建新的namespace（传入CLONE_*宏定义）**
UTS namespace：
提供主机名和域名的隔离，使容器能够通过服务名访问
IPC namespace（进程间通信）：
实现信号量、消息队列和共享内存等资源的隔离
PID namespace：
对进程内的PID重新标号，从1开始，每个PID namespace都有自己的计数程序，宿主机的PID namespace相当于创建进程的PID namespace的parent pid namespace，能看到子节点（child pid namespace)中的内容，但子节点不能看到父节点当中的内容，这样父节点能在外部管理容器内的进程
如果pid namespace中的某个进程的父进程被杀死，该进程成为孤儿进程，则会被当前pid namespace的init进程（pid为1，如/bin/bash）收养，成为其子进程
mount namespace:
通过隔离文件系统挂载点来隔离文件系统（当创建新的mount namespace时，会将所有挂载点复制给子进程，但在这之后，子进程对自己namespace内文件系统进行的操作不会影响到父进程namespace）
可以通过共享挂载机制传播挂载（主从挂载、共享挂载等）
network namespace:
提供网络资源的隔离，包括网络设备、协议栈、路由表、防火墙等等
默认的bridge模式：
每个容器有独立的network namespace，宿主机通过docker0网桥（虚拟网桥）来连接不同的network namespace，容器通过veth pair（虚拟以太网端口对，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来）连接docker0网桥，设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名。
如果容器想主动和外界通信，或者外界想访问容器内的服务（访问宿主机的端口），实际上这是通过iptables来管理的（进行了转发和NAT转换等操作）
host模式：
容器和宿主机共享network namespace，但其他namespace与宿主机隔离，容器用的是宿主机的ip与外界通信，性能较好但易产生端口冲突
container模式：
新创建的容器若指定container模式，则和已经存在的容器共享一个network namespace，与此容器共享ip和协议栈
user namespace
提供安全隔离，比如用户id，用户组，权限等，在子进程的user namespace中拥有新的用户和用户组，在父进程中的普通用户可能却成为子进程中namespace的超级用户，结构与pid namespace类似（树状结构），子user namespace中的用户和用户组需要与父user namespace中的用户和用户组相对应（做映射），这样这个user namespace才能与其他user namespace中的进程通信，甚至访问共享的文件（即对应到其他user namespace的用户和用户组并拥有相应的权限，如果没有相应的权限就不能在其他user namespace执行某些操作）</description></item><item><title>Docker基础知识</title><link>https://jessestutler.github.io/posts/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Sun, 07 Mar 2021 10:56:15 +0800</pubDate><guid>https://jessestutler.github.io/posts/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>Docker Docker拉取镜像流程图 Docker CLI 镜像命令 docker images 查看本地的镜像
docker images [image-name[:tag]] 默认不加参数就是-a，或者指定image的名字，可在image之上再加版本号 &amp;ndash;a 列出所有镜像 &amp;ndash;q [image] 列出镜像的id（-aq是列出所有的镜像id）
docker search 镜像
搜索远程仓库镜像（docker hub上查看更详细）
docker rmi [repo[:tag]]
删除本地镜像，使用方法与images相同，注意rmi是删除镜像，rm是删除容器
或者根据docker images -q [image]列出的id进行删除
docker tag source_image[:tag] target_image[:tag]
改镜像标签名（不然默认传到docker hub上的library仓库会被拒绝）
docker pull 镜像
默认拉取的是docker hub上的Image，也可以用一个容器跑一个local docker registry，然后让其他使用了docker pull并指定了docker registry地址和端口的机子从这台运行了docker registry的机子上拉镜像
docker push 镜像
将镜像上传到docker hub上的仓库或指定仓库
docker save -o [tar文件名] [镜像名]</description></item></channel></rss>