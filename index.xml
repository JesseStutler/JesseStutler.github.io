<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jesse's Blog</title><link>https://jessestutler.github.io/</link><description>Recent content on Jesse's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Tue, 18 May 2021 14:45:44 +0800</lastBuildDate><atom:link href="https://jessestutler.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>NSDI17 ExCamera</title><link>https://jessestutler.github.io/posts/nsdi17-excamera/</link><pubDate>Tue, 18 May 2021 14:45:44 +0800</pubDate><guid>https://jessestutler.github.io/posts/nsdi17-excamera/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/nsdi17-excamera/ -&lt;h1 id="nsdi17-excamera">NSDI17-ExCamera&lt;/h1>
&lt;p>这是一篇将video encoding改造到serverless平台上的文章&lt;/p>
&lt;p>论文链接：https://www.usenix.org/conference/nsdi17/technical-sessions/presentation/fouladi&lt;/p>
&lt;h2 id="mu框架">mu框架&lt;/h2>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h3 id="大致流程">大致流程&lt;/h3>
&lt;p>AWS s3 invoke第一个Worker（function实例），然后Worker与Coordinator建立TLS连接并保持（Coordinator通过RPC call来调控Worker的状态，Worker就是一个有限状态机），当Coordinator收到来自Worker的message时，就会根据状态转换逻辑产生新的状态给Worker并发送下一个RPC请求。&lt;/p>
&lt;p>Coorinator是dependency-aware的，他会根据Worker产生的output来指派可以处理这个output的worker，这样就可以顺序执行而不会产生死锁&lt;/p>
&lt;h2 id="出现原因">出现原因&lt;/h2>
&lt;p>传统的视频encoding速度太慢，一些实时的视频处理平台需要快速的视频上传业务&lt;/p>
&lt;blockquote>
&lt;p>背景知识：我们都知道视频由一帧帧的图片组成，对于将一段视频压缩成比特流来说，有些帧与帧之间，图片的某些部分是重复的，那压缩成比特流就不必重复，encoding过程就是花费cpu时间来寻找帧与帧之间的联系，从而尽可能的压缩输出的比特流大小；但是这样带来的问题就是帧与帧之间会存在依赖关系，从而不能将比特流从中间段进行解码，比如说直播的时候有不同的清晰度，想要切换成更高清的流。现在引入Stream Access Point来切分视频数据流&lt;/p>
&lt;/blockquote>
&lt;p>借助Stream Access Point技术（将视频数据流进行切分，各段数据流都是独立的，段与段之间的帧没有依赖关系，VP8/VP9使用的是
&amp;ldquo;key frame&amp;quot;概念），&lt;strong>可以将各段encoding过程改造成使用相同的function来处理&lt;/strong>，各段压缩完成之后再进行简单的连接（串行），形成一个完整的视频数据流&lt;/p>
&lt;h2 id="excamera-encoding流程">ExCamera encoding流程&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>（并行）使用&lt;em>vpxenc&lt;/em>（谷歌优化的encoder）encode六个帧，都以key frame为开头（也就是使用Stream Access Point分割视频数据流）,这代表一个chunk&lt;/p>
&lt;/li>
&lt;li>
&lt;p>（并行）使用ExCamera设计的encoder将原先&lt;em>vpxenc&lt;/em>生成的key frame替换成与前面部分的encoder产生的输出相关联的inter frame（因为key frame会影响压缩速率，所以ExCamera针对此进行了优化）。最后生成的chunk只有一个key frame为开头。&lt;/p>
&lt;blockquote>
&lt;p>这step2与step3之间还涉及到很多并行优化步骤，因为涉及到视频encode和decode背景，略过&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>（串行）将各个chunk顺序连接起来&lt;/p>
&lt;/li>
&lt;/ol>
- https://jessestutler.github.io/posts/nsdi17-excamera/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>ATC20——Faasm</title><link>https://jessestutler.github.io/posts/atc20faasm/</link><pubDate>Tue, 18 May 2021 14:43:26 +0800</pubDate><guid>https://jessestutler.github.io/posts/atc20faasm/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/atc20faasm/ -&lt;h1 id="atc20faasm">ATC20——Faasm&lt;/h1>
&lt;p>这是一篇关于webassembly sandbox的文章&lt;/p>
&lt;p>论文链接：https://www.usenix.org/conference/atc20/presentation/shillaker&lt;/p>
&lt;h2 id="为什么要提出wasm-sandbox本文是faaslet">为什么要提出WASM-sandbox（本文是Faaslet)？&lt;/h2>
&lt;p>大多数serverless平台使用的是容器承载function，但是对于容器来说，启动开销和过多的memory footprint仍然与serverless场景不太匹配（像边缘场景如果容器是overprovision的，性能会随着资源可用量的减少而下降；而且边缘如果是多租户的，long-running container也不合需求，如果资源不够用了需要频繁的驱逐），而且现有以容器为承载的方案（尽管有提出本地存储来减少访问数据开销的）会产生&lt;strong>冗余数据&lt;/strong>，每个函数都有一份拷贝，而且需要重复的序列化和网络开销。对比docker来说，faaslet能够极大的减少冷启动延迟，减少开销，让一台机器承载更多的sandbox&lt;/p>
&lt;h2 id="fasslet">Fasslet&lt;/h2>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqdjwbsburj30p009umyy.jpg" alt="截屏2021-05-10 下午7.21.46">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>function和其library，runtime都会编译为WASM；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cgroup做cpu周期隔离；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>network namespace做Network隔离和提供virtual network interface；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>faaslet以线程运行，共享进程资源；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>部分WASI+部分POSIX实现（图中Host interface）做system calls，因为WASI是基于compability-based security的，所以对于资源的访问是通过不可伪造的句柄来保存引用的&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>两层状态共享机制&lt;/li>
&lt;/ul>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>local状态共享就是多个faaslet（多个线程）共享父进程的同一块内存区域，global负责集群内状态的同步&lt;/p>
&lt;ul>
&lt;li>faaslet快照&lt;/li>
&lt;/ul>
&lt;p>预初始化faaslet并做成快照，可以减少冷启动时间和各种开销&lt;/p>
- https://jessestutler.github.io/posts/atc20faasm/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>ATC18——容器优化方案SOCK</title><link>https://jessestutler.github.io/posts/atc18%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88sock/</link><pubDate>Tue, 18 May 2021 14:41:22 +0800</pubDate><guid>https://jessestutler.github.io/posts/atc18%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88sock/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/atc18%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88sock/ -&lt;h1 id="atc18容器优化方案sock">ATC18——容器优化方案SOCK&lt;/h1>
&lt;p>这是一篇优化容器冷启动的文章&lt;/p>
&lt;p>论文链接：https://www.usenix.org/conference/atc18/presentation/oakes&lt;/p>
&lt;h2 id="解构containerdocker瓶颈">解构container（docker瓶颈）&lt;/h2>
&lt;ul>
&lt;li>Bind mount可能比AUFS（或overlay）性能更好&lt;/li>
&lt;li>频繁的container创建和删除（涉及到频繁的namespace的创建和删除，可能会有性能瓶颈，比如network namespace，并发的creation和cleanup越多延迟越高），是不是可以把一些不必要的namespace隔离给剔除或者进行一些优化（disable创建或删除时不必要的影响性能的功能）&lt;/li>
&lt;li>频繁的创建和删除cgroup不如reuse cgroup，比如维护一个初始化好的cgroup池&lt;/li>
&lt;li>当host上挂载的越多，mount namespace拷贝的速度就越慢，简单的做法可以考虑使用chroot&lt;/li>
&lt;/ul>
&lt;h2 id="sock优化方案">SOCK优化方案&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Lean containers:&lt;/p>
&lt;ul>
&lt;li>用bind mount代替overlay，分四层：系统层（base），package层（read-only，用来package caching），code层（lambda代码），scratch层（就是container layer，可写层）&lt;/li>
&lt;li>用cgroup pool来分配在container创建时分配cgroup，container删除时重新回到池中&lt;/li>
&lt;li>将mount namespace和network namespace省去，其瓶颈在docker瓶颈中已提到&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Zygote机制：&lt;/p>
&lt;p>Zygote container就是一些已经预import需要的package的容器，内含Zygote进程，这样从这个进程fork出的新进程（子进程）并创建出的新容器不需要做重复性的初始化工作，直接从内存读相同的内容就好了，也就是：&lt;/p>
&lt;p>&lt;strong>含Zygote进程的container&amp;ndash;&amp;gt;含从Zygote fork出的子进程的container&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>三级缓存：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>handler cache：&lt;/p>
&lt;p>将idle instance pause，不消耗cpu但是消耗内存，之后再有request过来unpause是比新创建一个container快的（warm start）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>install cache：&lt;/p>
&lt;p>lean containers中的package层，read-only且被所有container共享&lt;/p>
&lt;/li>
&lt;li>
&lt;p>import cache:&lt;/p>
&lt;p>就是Zygote机制，但是命中和驱逐机制需要定制。命中可能与传统cache不同，存在多命中的情况（handler需要的包可能既在tree cache中的子节点也可能是父节点），这时需要找到最合适的entry（也就是Zygote进程）；驱逐因为Zygote进程会都有相同的包而存在共享内存的情况所以比较复杂&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
- https://jessestutler.github.io/posts/atc18%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88sock/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>ATC18——窥探Serverless平台</title><link>https://jessestutler.github.io/posts/atc18%E7%AA%A5%E6%8E%A2serverless%E5%B9%B3%E5%8F%B0/</link><pubDate>Tue, 18 May 2021 14:31:18 +0800</pubDate><guid>https://jessestutler.github.io/posts/atc18%E7%AA%A5%E6%8E%A2serverless%E5%B9%B3%E5%8F%B0/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/atc18%E7%AA%A5%E6%8E%A2serverless%E5%B9%B3%E5%8F%B0/ -&lt;h1 id="atc18窥探serverless平台">ATC18——窥探serverless平台&lt;/h1>
&lt;p>这是一篇利用逆向工程测试Serverless平台的文章&lt;/p>
&lt;p>论文链接：https://www.usenix.org/conference/atc18/presentation/wang-liang&lt;/p>
&lt;h2 id="qa">QA&lt;/h2>
&lt;p>Q:隔离的减少会导致I/O，networking，coldstart等表现的下降？&lt;/p>
&lt;p>A:是的。如果VM中有多个instance实例会造成资源争夺的现象（见衡量指标中的I/O &amp;amp; network throughput）&lt;/p>
&lt;p>Q:同一VM是运行多个function instance吗？&lt;/p>
&lt;p>A：是。AWS可以通过I/O测试发现多个function instance共享/proc中的文件&lt;/p>
&lt;p>Q:不同租户的function实例可以放到同一VM里吗？&lt;/p>
&lt;p>A：可以但并没有平台采用（安全隔离性会有问题:side channel attack）&lt;/p>
&lt;p>Q:idle instance（暂无请求的实例，但是不会收用户费用）是要退出并收回资源还是再利用（先放到池里）处理后续的请求？&lt;/p>
&lt;p>&lt;a href="https://aws.amazon.com/cn/blogs/compute/container-reuse-in-lambda/">https://aws.amazon.com/cn/blogs/compute/container-reuse-in-lambda/&lt;/a>&lt;/p>
&lt;p>A:这个问题值得考量。一方面，idle instance会一直占用VM的资源；而另一方面，如果有突发的请求又可以减少instance的冷启动时间。所以折中来说，AWS采用的是将一个函数的一半的instance每300s停掉并回收资源，剩下的instance运行直到一个最大idle time为止。&lt;/p>
&lt;p>Q:多个request会被同个instance接收吗？&lt;/p>
&lt;p>A：会。Google针对负载过多的话会开新实例&lt;/p>
&lt;p>Q:function update是开新实例吗，还是在旧实例的基础上改？&lt;/p>
&lt;p>A：开新实例，负载会从旧实例慢慢过渡到新实例，但是有一个时间差&lt;/p>
&lt;h2 id="衡量指标">衡量指标&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Cold-start latency（&amp;amp; warm start latency）&lt;/p>
&lt;p>这里代表的是function的冷启动时间（AWS使用了VM池在function启动之前就准备接收function的调度，这样基本上只受scheduling latency的影响）&lt;/p>
&lt;p>warm start指function在执行完之后，暂时“冻住”，为不久后再有请求而“解冻”并处理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Function instance lifetime&lt;/p>
&lt;p>即使instance仍然在运行，但是到达一个lifetime也会被terminated，租户如果想用一个function维护in-memory state的话肯定想让这个instance运行地更久一点&lt;/p>
&lt;p>AWS instance lifetime中位数为6.2小时&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Maximum idle time before shut down&lt;/p>
&lt;/li>
&lt;li>
&lt;p>I/O &amp;amp; network throughput&lt;/p>
&lt;p>当VM中的function实例越多，每个function的I/O和network吞吐量会越小，而且会受到function分配到的内存的影响，function占用的内存越大，吞吐量越高。所以，存在一个&lt;strong>VM多instance的资源争用问题&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CPU usage（AWS是根据code的预配置memory量来分配cpu周期，memory量越多CPU周期越多，这样冷启动的时间也会减少越多，而且公平）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Memory usage&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="可以利用点">可以利用点&lt;/h2>
&lt;h3 id="优化调度">优化调度&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>AWS尝试将function调度视为一个装箱问题(bin-packing problem)，尽可能的将新生成的function实例装入已有的VM实例当中，以提高==内存利用率==。&lt;strong>调度与function code无关&lt;/strong>。但是，这也会引入&lt;strong>instance的资源争用问题&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果function update的话可能会造成新一轮请求仍然被旧实例（可能是旧的函数的新实例，也可能是未被shut down的旧函数的旧实例）处理，怎么优化调度器？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>既然冷启动时间用VM就绪池的方法可以减少VM启动的这一部分latency，如何再减少scheduling latency？&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="优化冷启动时间">优化冷启动时间&lt;/h3>
&lt;ul>
&lt;li>减少scheduling latency&lt;/li>
&lt;li>使用library caching减少函数库的加载时间，只加载需要的库（Unikernel）&lt;/li>
&lt;/ul>
&lt;h3 id="优化隔离性">优化隔离性&lt;/h3>
&lt;ul>
&lt;li>更多的创造instance新实例而不是使用旧实例（符合serverless理念）&lt;/li>
&lt;li>Short-lived instance&lt;/li>
&lt;li>small memory-footprint functons&lt;/li>
&lt;/ul>
- https://jessestutler.github.io/posts/atc18%E7%AA%A5%E6%8E%A2serverless%E5%B9%B3%E5%8F%B0/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>ATC18——高性能workflowSAND</title><link>https://jessestutler.github.io/posts/atc18%E9%AB%98%E6%80%A7%E8%83%BDworkflowsand/</link><pubDate>Tue, 18 May 2021 14:28:02 +0800</pubDate><guid>https://jessestutler.github.io/posts/atc18%E9%AB%98%E6%80%A7%E8%83%BDworkflowsand/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/atc18%E9%AB%98%E6%80%A7%E8%83%BDworkflowsand/ -&lt;h1 id="atc18高性能workflow-sand">ATC18——高性能workflow SAND&lt;/h1>
&lt;p>这是一篇关于优化serverless workflow的文章&lt;/p>
&lt;p>论文下载链接：https://www.usenix.org/conference/atc18/presentation/akkus&lt;/p>
&lt;h2 id="sandbox">Sandbox&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>同属于同一个workflow的function属于一个&lt;strong>application&lt;/strong>，&lt;strong>一个application一个container&lt;/strong>，而不是一个function一个container&lt;/p>
&lt;blockquote>
&lt;p>但是有可能会引入资源竞争问题？&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>当有request到来时，==通过fork function实例来快速水平扩展==（&lt;strong>实验证明，fork是最快的，比直接执行二进制文件创建进程都要快&lt;/strong>），而不是频繁的冷启动一个不同的container。而且，同一个function的不同实例（也就是进程）可以共享内存，库只要加载一次就够了，相比另起一个container的内存占用量，内存占用量少很多。function执行完之后可以回收资源，等有请求来了再fork新实例，相比为了解决负载尖峰而一直保持container idle占用资源，可以避免资源一直被占用。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="message-bus">Message Bus&lt;/h2>
&lt;p>&lt;strong>SAND使用了一个机制：同一台host中的function通过local message bus来沟通，不同host中的function通过global message bus来沟通，而且global message bus可以保存local message bus中的消息作为备份（用来容错）&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>tips：local/global message bus都为不同的funciton维护有不同的队列（或者topic），global像kafka这种实现有partition做容错，host agent订阅global message bus，本地function订阅local message bus。而且message bus不直接传递data，而是传递数据的引用（比如local可以通过in-memory的key-value存储，来快速获取数据，global可以通过分布式存储来获取数据），不仅存取数据快，这样检查状态和回滚也方便。&lt;/p>
&lt;/blockquote>
&lt;p>鉴于现有的serverless平台中的workflow沟通机制，即使两个function在同一台机子当中，也是要通过外部消息队列服务来存取的，这引入了极大的延迟，local message bus能够削减这段延迟时间&lt;/p>
&lt;h2 id="host-agent">Host Agent&lt;/h2>
&lt;p>Host agent是每台机子上的代理，他负责local message bus和global message bus的合作（比如备份，细节里会细说）；为自己机子上的函数从global message bus存取消息（订阅topic）；孵化容器和fork function&lt;/p>
&lt;h2 id="细节">细节&lt;/h2>
&lt;h3 id="如何做备份">如何做备份&lt;/h3>
&lt;p>当function产生message到local message bus当中自己的队列时，会产生&lt;strong>一份拷贝给host agent的队列&lt;/strong>，然后host agent将这份拷贝消息放到global message bus的这个function的队列（或者topic）当中，==作为备份并且打上标签表示完成状态==，host agent会追踪要接收这个消息的下一个function的完成进度，顺利完成会将状态转为finished，处理失败会将状态转为failed并交给另一个机子上的function处理&lt;/p>
&lt;h3 id="workflow流程">workflow流程&lt;/h3>
&lt;p>假设有两个function完成workflow，一台机子（两个partiton)&lt;/p>
&lt;p>Step1：user request发送给function1，global message bus将消息放到partition1&lt;/p>
&lt;p>Step2: host agent（host agent负责global的订阅）将消息从partition1取出并放到local message bus的function1的队列&lt;/p>
&lt;p>Step3.1: function1（function负责local的订阅）将消息从local的自己队列中取出，fork新实例并处理，然后产生下一个消息给funtion2，将消息放到local message bus的function2队列&lt;/p>
&lt;p>Step3.2：同时，会有一份3.1中产生的消息的==拷贝==放到local message bus的host agent的队列，host agent将这个消息放到global的partition2中作为==备份==，并打上标签表示状态‘processing'&lt;/p>
&lt;p>Step4.1: function2从local自己队列中取出消息并处理，因为他是workflow的最后一步，所以完成后直接产生新消息给local中的host agent队列，host agent将这个消息放到global中&lt;/p>
&lt;p>Step4.2：host agent追踪到funciton2顺利完成，将标签3.2中的消息改为finished表示完成&lt;/p>
&lt;p>Step5：回复user表示完成&lt;/p>
- https://jessestutler.github.io/posts/atc18%E9%AB%98%E6%80%A7%E8%83%BDworkflowsand/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Serverless分析</title><link>https://jessestutler.github.io/posts/serverless%E5%88%86%E6%9E%90/</link><pubDate>Tue, 18 May 2021 14:13:36 +0800</pubDate><guid>https://jessestutler.github.io/posts/serverless%E5%88%86%E6%9E%90/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/serverless%E5%88%86%E6%9E%90/ -&lt;h1 id="serverless分析">Serverless分析&lt;/h1>
&lt;p>本文根据Berkeley rise lab的综述Cloud Programming Simplifified:&lt;/p>
&lt;p>A Berkeley View on Serverless Computing并结合其他相关材料进行总结，探究serverless的研究点，本文会持续进行更新。&lt;/p>
&lt;p>&lt;em>简单的说，Serverless就是FaaS+BaaS&lt;/em>&lt;/p>
&lt;h3 id="特点">特点&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>按使用量付费（无请求时无资源无分配无花费，有请求时按使用量，按时间计算付费），性能提高（高并发量），autoscale，强隔离性（多租户），可供有突发流量情况而又无服务器扩展需求的公司使用；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>低请求量服务改造&lt;/strong>：原先需要一直监听请求的应用，当无请求来时需要一直占用资源，而改造成serverless可以用function代替原先的应用，这样无请求来临时可以down to zero，有请求来时再invoke一个或多个function实例（而且这些function是可以并行的）并进行处理；（不仅是针对可以减少资源使用量，而且可以应对流量尖峰）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由外部服务触发比如S3（有object更新，比如新增图片），消息队列（事件驱动，收到事件），或者以API gateway的形式（可以是以Backend或以function的形式）等待HTTP request到来触发&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>一定是&lt;/strong>stateless，无法保证写到memory或者local disk的数据（VM上）下次被invoked还能读到，需要借助外部存储服务来保存状态或数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>适合short-lived task&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>从serverful过渡到serverless就像从汇编语言过渡到高级语言一样，汇编语言计算一个c=a+b需要指定寄存器，存放，计算结果然后并存回，而serverful就像汇编语言一样需要先知道哪些资源是可用的，然后给资源加载code和环境，执行计算，再得到结果，这些原先需要平台使用者去知晓，但是serverless不需要programmer去知晓和管理资源，只需要&lt;strong>编写code，编写function，编写业务就够了&lt;/strong>&lt;/p>
&lt;h2 id="现今serverless的有限性">现今Serverless的有限性&lt;/h2>
&lt;h3 id="存储对于细粒度操作的局限性">存储对于细粒度操作的局限性&lt;/h3>
&lt;p>因为function之间是相互隔离的，&lt;strong>所以需要借助外部存储服务(BaaS)来提供状态的支持&lt;/strong>，这是serverless的特性所致。但是对于划分到function这么细粒度的操作来说，现在的外部存储服务要不是太贵（access或者storage）要不就是延迟太高，e.g:对象存储比如AWS S3等，access花费和延迟过高；key-value数据库存储费用高，扩容慢；内存存储如redis等没有容错性，不能自动扩缩。当然这要看应用的要求，但还是与serverless理想的存储方案相差不少。&lt;/p>
&lt;h3 id="缺少细粒度的消息沟通">缺少细粒度的消息沟通&lt;/h3>
&lt;p>背景：两个task合作，taskA需要taskB的output作为input，但是不知道何时output会过来，所以需要引入消息中间件，但是现有的消息中间件对于细粒度(task/function)操作的延迟和花费太高&lt;/p>
&lt;p>可能的解决方案：自己设计消息通知机制比如长期运行一个汇集消息的server，能够以命名的方式直接定位到function实例从而获取到ouput等&lt;/p>
&lt;h3 id="标准沟通模式对于细粒度的性能太差">标准沟通模式对于细粒度的性能太差&lt;/h3>
&lt;p>背景：broadcast，shuffle，aggregation都是分布式系统中重要的原语，但是如果划分粒度过细，比如拿聚合来说，VM实例中的function如果本地不做聚合而每次聚合都需要到远端聚合，那么这个消息数量会成倍增加，shuffle则更多&lt;/p>
&lt;h3 id="冷启动的局限性">冷启动的局限性&lt;/h3>
&lt;p>1）启动function需要一定时间（分配和加载资源：分配VM，初始化container，将function的静态文件拷贝到container）&lt;/p>
&lt;p>2）需要一些时间去下载函数执行环境（OS，库，语言的runtime比如JVM等）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>函数的package依赖需要经过远端的download，local install，import过程，这个时间比较长，是否可以在本地machine上预先下载好所有语言涉及的包？（通过压缩的方式存储）这样直接去本地加载package，省去去远端下载package的时间。&lt;strong>所有container通过overlayfs或者bind mount共享已经安装好的package&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SOCK：利用Zygote机制预import一些需要的package（这样的Zygote很多，需要预import什么package就fork出新的Zygote），这样从Zygote进程fork出的新子进程不需要进行同样的初始化操作，直接从内存读取即可（减少开辟新内存的消耗）&lt;/p>
&lt;blockquote>
&lt;p>tips：fork出的子进程与父进程共享堆栈，fd，代码段，由于copy-on-write，只有子进程写时才会完全拷贝&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>含Zygote进程的container&amp;ndash;&amp;gt;含从Zygote fork出的子进程的container&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>3）有些应用对于代码需要做一些定制的初始化操作，需要花费一定时间（比如加载和初始化数据结构，库等）&lt;/p>
&lt;p>4）如果需要频繁冷启动，namespace的频繁creation和cleanup需要性能损耗&lt;/p>
&lt;h4 id="什么时候冷启动会发生">什么时候冷启动会发生？&lt;/h4>
&lt;ol>
&lt;li>当function的code或者配置改变的时候，或者function第一次部署的时候&lt;/li>
&lt;li>idle instance被shut down&lt;/li>
&lt;li>instance到了最大age被shut down（即使仍然在运行）&lt;/li>
&lt;li>之前的instance都在忙于处理请求，需要横向扩展的时候&lt;/li>
&lt;/ol>
&lt;h4 id="什么时候需要考虑冷启动的影响">什么时候需要考虑冷启动的影响？&lt;/h4>
&lt;p>也许像要访问存储服务的function本来就需要等待存取的latency，冷启动时间相对这段latency可有可无；也许实时数据流服务会频繁地invoke function，function会一直处理event很多次（可能200000次在到达最大age之前），那冷启动时间也可有可无。&lt;/p>
&lt;p>但是对于请求量较少的function，可能一小时invoke一次，就有可能中间被shut down，需要每次都冷启动，那就需要考虑冷启动的开销，如果冷启动需要加载的依赖和库过大，就有可能需要很多的冷启动时间；对于需要快速回应的应用也需要考虑冷启动的影响&lt;/p>
&lt;h4 id="解决冷启动方案">解决冷启动方案&lt;/h4>
&lt;ol>
&lt;li>AWS使用VM就绪池，在function启动之前就准备接收function的调度，这样基本上只受scheduling latency的影响&lt;/li>
&lt;li>尽可能的减少依赖，尽可能地用加载较快的语言（像Java中的JVM加载较慢）&lt;/li>
&lt;/ol>
&lt;h4 id="降低冷启动时间的好处">降低冷启动时间的好处&lt;/h4>
&lt;ol>
&lt;li>可以让idle instance更少一些，可用资源更多一些（这样就不用因为担心冷启动时间过长而一直等待后续的请求了）&lt;/li>
&lt;/ol>
&lt;h2 id="serverless可以探索的点">Serverless可以探索的点&lt;/h2>
&lt;h3 id="abstraction">Abstraction&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Resouce requirements&lt;/p>
&lt;p>不要让serverless平台的使用者来指定要使用多少资源，这样违背于serverless的理念（不应该管理资源），而且会降低资源的利用率。&lt;strong>更好的做法&lt;/strong>是让cloud provider来推断出需要使用多少资源，比如&lt;strong>静态代码分析，归档之前跑完的数据，动态编译等等&lt;/strong>，总而言之就是要自动的推断出需要多少资源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Data dependencies&lt;/p>
&lt;p>现在的serverless平台无法知晓function之间存在什么数据依赖，甚至需要交换的数据的规模。&lt;strong>更好的做法&lt;/strong>是暴露一个API让应用指明function的computation graph，以便更好地放置function的位置；而且可以引入coordinator来解决function之间顺序依赖的关系，和调控function的状态（function为有限状态机，收到消息发生状态改变）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="system">System&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Storage&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Ephemeral storage&lt;/strong>（暂时存储）&lt;/li>
&lt;/ol>
&lt;p>既然serverless computing需要的是暂时的状态存储，当计算结束时这些状态就可以丢弃，那么可以用暂时存储的方案，比如用内存存储（以分布式内存存储的方式），利用RDMA来减少延迟，利用共享内存的方式来减少serverful computing中内存被VM实例独占，无用内存碎片过多的情况&lt;/p>
&lt;ol start="2">
&lt;li>Durable storage（长期存储）&lt;/li>
&lt;/ol>
&lt;p>大部分都是暂时存储的情况（我觉得serverless也是适用于暂时存储），但是如果针对于设计serverless数据库的话需要长期存储，可能需要多个存储服务的结合，以及像SSD这样提高硬盘的IOPS&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Coordination/signaling service&lt;/p>
&lt;p>&lt;strong>解决缺少细粒度的消息沟通和数据一致性问题&lt;/strong>（因为多个function可能会放到一起，所以分布式系统中的一致性算法和leader election不适用）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Minimize startup time&lt;/p>
&lt;p>&lt;strong>解决冷启动的局限性&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>解决1）：提供更新的轻量级的隔离机制（e.g:Firecracker）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>解决2）：利用unikernels，预配置硬件，静态分配数据结构，只包含应用所需的驱动和函数库等；或者动态地加载函数库（有点类似ddl）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>解决3）：提前做初始化操作；当做完初始化操作call readiness API去通知function工作；利用warm pool存放已经加载好的拥有流行的系统和库的实例等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>WebAssembly&lt;/strong>，有一项调查显示其实50%的function运行时间不超过100ms，但是启动container和加载runtime时间却远远超过100ms以上。&lt;/p>
&lt;blockquote>
&lt;p>VM或者container初始化需要设置system library以供系统调用使用，这会引入开销；且VM或container下的现有付费模型是根据内存使用量和使用时间来计算的，像细粒度的cpu周期使用量等没有涉及到&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="network">Network&lt;/h3>
&lt;p>解决标准沟通模式对于细粒度的性能太差问题，解决方案可同Abstraciton——data dependencies，让应用提供一个computation graph，以便serverless平台能够将一些function放置到同一VM实例中，&lt;strong>减少通过network发送的消息，尽量在本地先处理完&lt;/strong>&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>1）eBPF Tail &amp;amp; Function Calls？&lt;/p>
&lt;h3 id="security">Security&lt;/h3>
&lt;p>暂不考虑&lt;/p>
&lt;h3 id="architecture">Architecture&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>硬件的异构性和性能提升陷入瓶颈&lt;/p>
&lt;p>背景：同样的架构但是不同时代的产品，虽然价格一样但是速度可能不同；硬件性能提升陷入瓶颈&lt;/p>
&lt;p>解决方法：&lt;/p>
&lt;p>1）使用语言特定的处理器提升处理速度&lt;/p>
&lt;p>2）使用DSA（Domain Specific Architectures），比如GPU加速图像处理，TPU加速factor处理等&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="serverless已经适配的应用持续更新">Serverless已经适配的应用（持续更新）&lt;/h2>
&lt;h3 id="multimedia-processing">Multimedia processing&lt;/h3>
&lt;ul>
&lt;li>比如有一个图片上传（比如用户上传头像）到AWS S3这样的object storage，触发function将图片处理成缩略图，然后重新存回到AWS S3或者网站自己的存储服务当中&lt;/li>
&lt;li>或者有一个文件上传后触发function将文件进行压缩然后重新存回&lt;/li>
&lt;/ul>
&lt;h3 id="database">Database&lt;/h3>
&lt;ul>
&lt;li>当数据库更新的时候invoke一些function进行一些动作，比如添加或删除的时候&lt;/li>
&lt;li>网站上有天气系统，当点击查看时触发function取得数据库的天气数据&lt;/li>
&lt;li>支撑购物系统快速获取商品信息&lt;/li>
&lt;/ul>
&lt;h3 id="iot-sensor-input-messages">IoT sensor input messages&lt;/h3>
&lt;ul>
&lt;li>处理或过滤来自IoT device的MQTT消息，实时性要求高&lt;/li>
&lt;/ul>
&lt;h3 id="stream-processing-at-scale">Stream processing at scale&lt;/h3>
&lt;ul>
&lt;li>连接消息源处理事件流，实时性要求高，serverless弹性扩缩能力和高并发能力天然适合&lt;/li>
&lt;/ul>
&lt;h3 id="batch-jobs-or-scheduled-tasksworkflow需要给定状态图">Batch jobs or scheduled tasks（workflow，需要给定状态图）&lt;/h3>
&lt;ul>
&lt;li>一天内不会需要很多时间处理的batch job，可以在一天内的其他时间不需要一直running&lt;/li>
&lt;/ul>
&lt;h3 id="http-rest-apis-and-web-applications天然适合">HTTP REST APIs and web applications（天然适合）&lt;/h3>
&lt;ul>
&lt;li>简单的REST操作适合serverless&lt;/li>
&lt;/ul>
&lt;h2 id="serverless可以优化的应用持续更新">Serverless可以优化的应用（持续更新）&lt;/h2>
&lt;p>&lt;strong>优点&lt;/strong>&lt;/p>
&lt;p>1）function实例启动快&lt;/p>
&lt;p>2）花费少（按使用量计费）&lt;/p>
&lt;p>3）可以invoke多个实例并行处理请求（&lt;strong>主要原因&lt;/strong>）&lt;/p>
&lt;p>&lt;strong>引入的问题&lt;/strong>（如何将原来的应用迁移成细粒度的function）&lt;/p>
&lt;p>1）如果仅仅是简单地将应用划分成不同的代码段，一个代码段一个function，那这些不同的function不能很好地用到warm start，每次都是cold start&lt;/p>
&lt;p>2）可能会受到平台实例并发数量的限制&lt;/p>
&lt;p>3）如果function instance是有顺序协作关系的（以链的形式），可能会发生死锁&lt;/p>
&lt;p>4）并发性能是提高了，但是如何保证拥有和改造前应用相近的质量？（是否要斟酌牺牲一点？）&lt;/p>
&lt;h3 id="video-encodingcompute-heavy-task">video encoding(compute-heavy task)&lt;/h3>
&lt;p>背景：现有的编码方案需要花费数十分钟甚至数十小时去上传视频&lt;/p>
&lt;p>已有的解决方案：ExCamera，以函数语义并行执行编码的慢的部分，串行快的部分&lt;/p>
&lt;h3 id="mapreduce">MapReduce&lt;/h3>
&lt;p>背景：Map，Shuffle，Reduce皆可以移植到serverless computing，在mapreduce期间资源需求变化很大&lt;/p>
&lt;p>已有的解决方案：只解决了Map-Only job，整套的MapReduce待解决&lt;/p>
&lt;h3 id="线性代数">线性代数&lt;/h3>
&lt;p>背景：并行数量在计算期间变化很大，移植到serverless computing可以提高执行速度并且提高资源利用率&lt;/p>
&lt;p>已有的解决方案：Numpywren&lt;/p>
&lt;h3 id="machine-learning">Machine learning&lt;/h3>
&lt;p>背景：预处理，模型训练等不同阶段的资源需求变化大，与线性代数类似&lt;/p>
&lt;p>已有的解决方案：Cirrus&lt;/p>
&lt;h3 id="database不太好解决">Database（不太好解决）&lt;/h3>
&lt;p>背景：使用cloud function来进行数据存储，但是需要存储服务的支持（Backend）；但是数据库连接又需要特定协议，从函数层面上不到网络层这一层；&lt;/p>
&lt;h2 id="references收集">References收集&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.symphonia.io/posts/2017-11-14_learning-lambda-part-8">https://blog.symphonia.io/posts/2017-11-14_learning-lambda-part-8&lt;/a> Learning Lambda — Part 8 cold starts&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.symphonia.io/posts/2020-06-30_analyzing_cold_start_latency_of_aws_lambda">https://blog.symphonia.io/posts/2020-06-30_analyzing_cold_start_latency_of_aws_lambda&lt;/a> Analyzing Cold Start latency of AWS Lambda&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://archive.fosdem.org/2020/schedule/event/containers_bpf/">https://archive.fosdem.org/2020/schedule/event/containers_bpf/&lt;/a> BPF as a revolutionary technology for the container landscape&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/cncf/wg-serverless/tree/master/whitepapers/serverless-overview">https://github.com/cncf/wg-serverless/tree/master/whitepapers/serverless-overview&lt;/a> CNCF Serverless Whitepaper v1.0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Farxiv.org%2Fpdf%2F2010.07115.pdf&lt;/p>
&lt;p>SSVM——WebAssembly Virtual machine&lt;/p>
&lt;/li>
&lt;/ul>
- https://jessestutler.github.io/posts/serverless%E5%88%86%E6%9E%90/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Raft</title><link>https://jessestutler.github.io/posts/raft/</link><pubDate>Tue, 09 Mar 2021 16:30:52 +0800</pubDate><guid>https://jessestutler.github.io/posts/raft/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/raft/ -&lt;h1 id="raft">Raft&lt;/h1>
&lt;h2 id="引言">引言&lt;/h2>
&lt;p>Raft是分布式数据一致性算法，用于解决PAXOS多年来晦涩难懂且难以工程复现的问题，本文对Raft发表的原文论文进行了大致解读&lt;/p>
&lt;h2 id="基本算法内容">基本算法内容&lt;/h2>
&lt;h3 id="basics">Basics&lt;/h3>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8plfwpl8j30ef05o0t3.jpg" alt="图 5">&lt;/p>
&lt;h4 id="followercandidateleader">Follower,Candidate,Leader&lt;/h4>
&lt;p>每个server分为三种状态（状态转换图见Leader election）：&lt;/p>
&lt;ul>
&lt;li>Follower：只接受RPC请求（就算收到来自client的请求也会重定向给leader）&lt;/li>
&lt;li>Candidate：参加竞选，可以发送RequestVote RPC，同样也可以接受请求&lt;/li>
&lt;li>Leader（only one）：&lt;strong>只有Leader可以处理来自client的请求&lt;/strong>，可以发送AppendEntries RPC，可以是追加日志条目用，也可以是心跳检测用（定期检测其他server是否还活着，通过&lt;strong>无条目追加&lt;/strong>的AppendEntries RPC来做到）&lt;/li>
&lt;/ul>
&lt;h4 id="term任期">term——任期&lt;/h4>
&lt;p>Raft将时间随机划分，每一段称为&lt;strong>任期&lt;/strong>（任期是单调递增的），任期都以一次选举开始，选举可以是选出leader也可以是未能选出leader（未能选出leader就直接进入下一任期）&lt;/p>
&lt;p>&lt;strong>每台server发现自己的任期小于其他机器就需要update到最新&lt;/strong>&lt;/p>
&lt;h4 id="entry条目">entry——条目&lt;/h4>
&lt;p>条目就是指日志的条目，由client发来的&lt;code>command+任期数（term number，用来检测不一致性）+index（条目索引）&lt;/code>构成&lt;/p>
&lt;h3 id="leader-election">Leader election&lt;/h3>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8pln7a9hj30hn07x0tq.jpg" alt="图 4 ">&lt;/p>
&lt;p>状态转换图分析：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Starts up:&lt;/p>
&lt;p>初始时，每台server都是Follower&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Follower&amp;mdash;&amp;gt;Candidate：&lt;/p>
&lt;p>当超出election timeout时间（长时间未收到有Leader发过来的RPC消息，说明当前cluster未选出leader，或者是未收到来自candidate的RequestVote RPC），Follower增加自己的当前任期数，并将自己转换为Candidate；参加竞选leader，给自己投票，然后并发地向其他server发送RequestVote RPC请求，需要他们给自己进行投票（&lt;strong>一般规则是先收到谁请求就投谁&lt;/strong>）；重设election timeout&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Candidate&amp;mdash;&amp;gt;Candidate：&lt;/p>
&lt;ul>
&lt;li>选举发生投票分歧&lt;/li>
&lt;/ul>
&lt;p>未能选出leader（发生投票分歧），比如有好几台Candidates票数一致的情况，或者大家都是Candidate（不可能给竞争对手投票是吧:P ），增加自己的当前任期数，并开始新一轮的选举。不过这样有可能造成一直产生投票分歧的情况，打破这种情况并选出leader的机制就是&lt;strong>election timeout，Candidates从时间段中随机给自己选一个election timeout时间，如果发生投票分歧，先超时的Candidate赢得选举&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Candidate收到Leader（已经暂时选出的）的RPC请求，发现其任期比自己旧，拒绝请求并保持Candidate状态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Candidate&amp;mdash;&amp;gt;Leader：&lt;/p>
&lt;p>赢得竞选（获得&lt;strong>大多数&lt;/strong>servers的投票）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Leader&amp;mdash;&amp;gt;Follower:&lt;/p>
&lt;p>通过RPC的回复发现自己的任期已过期（有比自己更新的任期），退回到Follower&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Candidate&amp;mdash;&amp;gt;Follower：&lt;/p>
&lt;ul>
&lt;li>输掉选举（收到了来自己已选出的leader的RPC，&lt;strong>但要确定自己的任期至少和Leader的任期相同，参考第3步&lt;/strong>）&lt;/li>
&lt;li>通过RPC的回复发现自己的任期已过期（有比自己更新的任期），退回到Follower&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="log-replication">Log Replication&lt;/h3>
&lt;p>&lt;strong>首先要说明的是，Leader只追加条目（entry）而不修改或删除entry&lt;/strong>&lt;/p>
&lt;p>Leader通过AppendEntries RPC来加条目复制到其他servers上，如果有server挂了他也会一直重复尝试发送。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Follower如何确定自己Leader发过来的条目可以追加？&lt;/p>
&lt;p>Leader发送的条目会包括索引号和任期数，如果Follwer没有找到相同索引号和任期数的条目，就拒绝请求，找到了就说明这个条目之前的条目都是相同的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>条目什么时候应该被apply到各个机器上？&lt;/p>
&lt;p>我们称之为&lt;strong>提交&lt;/strong>（commited），当条目&lt;strong>已经被复制到大多数的servers&lt;/strong>上（维护一个replicas来确定），这些条目（包括之前的未提交的条目，前leader剩下的未提交的条目）就都会被提交，每台server都会维护一个highest index表示最后的已经提交的条目，已表示这之前的条目都已提交&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="leader-crash所导致的log不一致问题">Leader crash所导致的log不一致问题&lt;/h3>
&lt;p>这个就是关键要解决的，Leader崩溃（然后发生Leader exchange）可能会导致一系列各server上&lt;strong>log不一致&lt;/strong>的问题（前leader可能还未完全复制给所有机器），&lt;strong>Follower可能会带有现Leader没有的log，或者更复杂的不一致问题&lt;/strong>，那如何解决呢？&lt;/p>
&lt;p>&lt;strong>覆盖&lt;/strong>。&lt;/p>
&lt;p>如果有不一致的log，Leader需要找到和Follower的日志中相同的&lt;strong>最后一个条目&lt;/strong>（也就是索引号和任期数相同，说明之前的条目都相同），然后将后面不一样的条目都&lt;strong>覆盖成Leader的&lt;/strong>（当然缺少的话就直接追加）。&lt;/p>
&lt;blockquote>
&lt;p>解决方法：当新leader出现时，他会先进行一致性检查，他会维护一个nextIndex，表示下一个要发送给follower的条目的索引号，当follower拒绝追加请求时（发现不一致），leader就减小nextIndex的大小，&lt;strong>直到条目相同为止&lt;/strong>，然后leader把这之后的条目全部覆盖掉Follower的日志&lt;/p>
&lt;/blockquote>
&lt;h3 id="safety">Safety&lt;/h3>
&lt;p>当leader提交的时候万一发生Follower崩溃的情况，而Follower复原之后又当上新leader，可能会出现覆盖之前已经提交的entry的情况，继而造成不同server最后执行了不同command的情况&lt;/p>
&lt;blockquote>
&lt;p>解决方法：加上election restriction，对于candidate&lt;strong>必须要涵盖之前已经所有已经提交的entry&lt;/strong>，也就是说就算candidate获得了大多数票数的情况下，必须以涵盖所有已提交entry为前提，否则不能赢得选举&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>那如何保证candidate涵盖了所有已经提交的条目呢？&lt;/p>
&lt;p>candidate的日志必须是最新的（up-to-date）。怎样规定最新呢？两个server的日志如果任期更新者就是最新的，或者任期相同而拥有更长索引者就是最新的。如果candidate发送RequestVote RPC，&lt;strong>而其log不比voter新，voter就要拒绝投票给candidate&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>还有的情况是，旧leader未能提交entry，而新leader也无法确定这个entry是否已提交&lt;/p>
&lt;blockquote>
&lt;p>leader只为当前任期是否应该提交维护一个replicas，也就是replicas如果是大多数的话就提交&lt;/p>
&lt;/blockquote>
&lt;h3 id="follower-and-candidate-crashes">Follower and candidate crashes&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>当Follower和candidate崩溃时，Leader会一直无限期的重发RPC直到它们重启并成功收到为止&lt;/p>
&lt;/li>
&lt;li>
&lt;p>保证幂等性：如果server在响应RPC前崩溃，要保证恢复后RPC的响应结果是一样的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="timing-and-availability">Timing and availability&lt;/h3>
&lt;blockquote>
&lt;p>广播时间 &amp;laquo; 选举超时时间 &amp;laquo; 平均崩溃时间&lt;/p>
&lt;/blockquote>
&lt;p>系统的时间要遵循上述不等式，第一个不等式避免Follower收不到心跳消息而转而变成Candidate状态进入新的选举，第二个不等式避免一直无法选出Leader&lt;/p>
&lt;p>广播时间和平均崩溃时间由现实决定，&lt;strong>选举超时时间一般在10ms到500ms之间&lt;/strong>&lt;/p>
&lt;h2 id="优化">优化&lt;/h2>
&lt;h3 id="cluster-membership-changes">Cluster membership changes&lt;/h3>
&lt;p>如果集群需要更改配置，比如替换掉原来的机器或者加入新机器，先将集群停掉，更改完配置之后再上线会让集群有段时间不可用，但是如果直接将旧配置改为新配置有可能会造成集群同时出现两个leader的情况。Raft用一种两阶段算法，引入了一个过渡配置——共同一致，集群同时可以有旧配置和新配置的存在，但需要进行一定的限制，具体参考：https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md#6-%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E5%8F%98%E5%8C%96&lt;/p>
&lt;h3 id="log-compaction">Log compaction&lt;/h3>
&lt;p>避免存储日志过多（提交了之后的日志条目会占用过多磁盘空间，其实只要保留一点metadata用来标识和回滚就够了）&lt;/p>
&lt;blockquote>
&lt;p>解决方法：snapshot（快照），&lt;strong>由每台server自己&lt;/strong>将已经提交的条目信息用metadata的形式记录下来形成snapshot，然后就可以把已经提交的日志条目丢弃了，这样就可以减少日志占用的空间，而且方便一致性检查，就是我们前文提到的当leader crash时出现的一系列问题，可以快速检索metadata获取最后提交的条目信息&lt;/p>
&lt;/blockquote>
&lt;p>这里引入一个InstallSnapshot RPC，当出现server已经提交而Follower还未提交的情况（比如刚刚加入集群的机器或者比较慢的未收到entry的机器），这时候Follower的snapshot是远远落后的&lt;/p>
&lt;h3 id="client-interaction">client interaction&lt;/h3>
&lt;p>client是随机请求集群中的server，不一定是leader，如果是Follower收到了请求他会重定向给Leader（AppendEntries RPC中包含了Leader的地址）&lt;/p>
&lt;p>当Leader已经执行了client的请求发来的command，但是响应client前崩溃，client可能会重新提交这个command的请求，造成两次执行同样的command，我们需要给每个command维护一个serial number，表示command序列，当已经执行过了这个serial number的command，收到同样的请求就不再执行&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;p>&lt;a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md&lt;/a>（论文中文翻译和原文）&lt;/p>
&lt;p>&lt;a href="https://raft.github.io/">https://raft.github.io/&lt;/a>（raft概述和动画演示，以及论文原文下载）&lt;/p>
- https://jessestutler.github.io/posts/raft/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Golang基础</title><link>https://jessestutler.github.io/posts/golang%E5%9F%BA%E7%A1%80/</link><pubDate>Sun, 07 Mar 2021 11:25:55 +0800</pubDate><guid>https://jessestutler.github.io/posts/golang%E5%9F%BA%E7%A1%80/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/golang%E5%9F%BA%E7%A1%80/ -&lt;h1 id="golang">GOLANG&lt;/h1>
&lt;h2 id="引言">引言&lt;/h2>
&lt;p>云原生体系下，golang一定是必须要掌握的高级语言，golang内置的goroutine契合分布式架构的设计，越来越多的关于云的开源项目采用go进行实现。本文参考：http://c.biancheng.net/golang/intro/ ，本文对go的基础知识进行了大致介绍，可参照右侧的大纲检索，本文会持续更新。&lt;/p>
&lt;p>这里笔者也推荐一些go练手项目：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://geektutu.com/post/gee.html">https://geektutu.com/post/gee.html&lt;/a> 极客兔兔的7天用go从零实现系列（必须强烈推荐👍，一天天打下来能对很多go的开源项目有个大致的认识，也能学到很多技巧）&lt;/li>
&lt;li>&lt;a href="https://courses.calhoun.io/courses">https://courses.calhoun.io/courses&lt;/a> 需要挂梯子，作为一些对于go不同的包的练手项目不错&lt;/li>
&lt;/ul>
&lt;h2 id="常用命令">常用命令&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;code>go install [package-name] &lt;/code>&lt;/p>
&lt;p>编译并安装包，如果不是main包则会安装到pkg底下作为库包，如果是main包则会安装到bin底下作为可执行文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>go doc [package] [func] &lt;/code>&lt;/p>
&lt;p>go手册&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>go build [file or package]&lt;/code>&lt;/p>
&lt;p>如果是main包，生成可执行文件（可执行文件名同文件夹名），如果不是main包，不生成可执行文件，只进行编译&lt;/p>
&lt;p>如果是单个.go文件，main包中&lt;strong>只能对含main函数&lt;/strong>的go文件进行编译并生成可执行文件，其他包只进行编译&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="go-module">go module&lt;/h3>
&lt;p>&lt;strong>以后默认用go module的方式进行包管理和添加依赖，以后workspace不必在$GOPATH下，$GOPATH就存放下载的包和编译好的课执行文件&lt;/strong>&lt;/p>
&lt;p>root workspace底下有两个文件，一个是go.mod（包管理），一个是go.sum（包校验），真正的包下载好放在$GOPATH/pkg/mod底下&lt;/p>
&lt;p>&lt;strong>在root workspace底下&lt;/strong>用&lt;code>go mod init[模块名]&lt;/code>生成go.mod，模块名命名格式为example.com/xxx..（一般就github.com/foo这样），然后引用workspace底下子目录的go文件，用&lt;code>模块名/子目录名&lt;/code>的格式引用&lt;/p>
&lt;p>&lt;strong>给项目添加依赖（写进 go.mod)的两种方法&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>你只要在项目中有 import，然后 go build 就会 go module 就会自动下载并添加（&lt;strong>perfect way&lt;/strong>）&lt;/li>
&lt;li>自己手工使用 go get 下载安装后，会自动写入 go.mod&lt;/li>
&lt;/ul>
&lt;h4 id="常用命令-1">常用命令&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>&lt;code>go mod init&lt;/code>&lt;/p>
&lt;p>初始化module&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>go mod tidy&lt;/code>&lt;/p>
&lt;p>下载缺少的包，清除没有用上的包&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>go list&lt;/code>&lt;/p>
&lt;p>-m all列出所有模块&lt;/p>
&lt;p>-u -m all列出所有模块及其可能拥有的更新&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>go get -u [module] &lt;/code>&lt;/p>
&lt;p>更新模块及其依赖到最新版本&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="变量">变量&lt;/h2>
&lt;blockquote>
&lt;p>简短变量声明被广泛用于大部分的局部变量的声明和初始化。var 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>一般以 &lt;code>变量名:=变量值&lt;/code>的形式由编译器自行判断类型并赋值（适用于局部变量，用在初始化的时候，注意是**:=而不是=，左部变量必须未定义，否则会产生编译错误**），**局部变量不可重复声明，声明的变量没有使用也会编译错误(import包如果没有用到也会报错，与java给个警告不同**，全局变量可以声明但不使用，或以&lt;code>var 变量名 type = 变量值&lt;/code>（var 变量名 = 变量值，自动识别）的形式赋值（适用于全局变量，用在暂时不需要初始化只需要声明的时候，**go也会给未进行初始化的变量赋值**）。&lt;/li>
&lt;li>在同一行同时赋值，编译器会根据顺序将右边的值依次赋予给左边的变量，e.g：&lt;/li>
&lt;/ul>
&lt;p>a,b,c := 1,2,&amp;ldquo;hello&amp;rdquo;，也适用于一个函数有多个返回值时&lt;/p>
&lt;ul>
&lt;li>
&lt;p>交换值a,b=b,a&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>匿名变量&lt;/strong>的特点是一个下画线“_”，本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。e.g:&lt;/p>
&lt;p>&lt;code>a, _ := GetData()&lt;/code>当函数有多个返回值但是暂时不需要赋给这么多变量时，用“_&amp;ldquo;吞掉返回的值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>go中使用==或者!=等进行比较时，两边的变量类型必须相同，不相同必须进行强制类型转换（&lt;strong>注意bool无法与其他类型强转&lt;/strong>）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>双引号声明字符串字面量不能跨行，需要用反引号`，多行字符串一般用于内嵌源码和内嵌数据等（换行会被保留，但是无法用转义）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>rune类型代表一个utf-8字符&lt;/strong>，它同等于int32，byte可表示一个ASCII字符，它同等于uint8&lt;/p>
&lt;/li>
&lt;li>
&lt;p>类型转换：go不能隐身转换，需要声明类型转换，valueOfTypeB = typeB(valueOfTypeA)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>iota（多用于枚举，多常量声明形式，如以下代码，每显式声明一个const（或组） ，iota都会初始化为0，const组中每增加一行，iota就加1：&lt;/p>
&lt;pre>&lt;code>const (
Sunday = iota （Sunday=0）
Monday （如果const中没有显式赋值，则赋值为前一行的值，即iota）
Tuesday
Wednesday
Thursday
Friday
Saturday
)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>类型别名：type TypeAlias = Type （TypeAlias仍然是Type型，只不过取了别名）&lt;/p>
&lt;p>类型定义： type TypeAlias Type （没有等号，相当于C语言中的typedef，TypeAlias是一个新类型了），这种类型和原来的类型是不一样的静态类型，需要使用类型转换&lt;/p>
&lt;p>类型断言：因为接口变量的动态类型是变化的，有时我们需要知道一个接口变量的动态类型究竟是什么，这就需要使用类型断言，断言就是对接口变量的类型进行检查，其语法结构如下：（&lt;strong>可以用于interface{}类型变量转换为其他类型变量&lt;/strong>）&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">value, ok := x.(T)
x表示要断言的接口变量&lt;span style="color:#a61717;background-color:#e3d2d2">；&lt;/span>
T表示要断言的目标类型&lt;span style="color:#a61717;background-color:#e3d2d2">；&lt;/span>
value表示断言成功之后目标类型变量&lt;span style="color:#a61717;background-color:#e3d2d2">；&lt;/span>
ok表示断言的结果&lt;span style="color:#a61717;background-color:#e3d2d2">，&lt;/span>是一个bool型变量&lt;span style="color:#a61717;background-color:#e3d2d2">，&lt;/span>true表示断言成功&lt;span style="color:#a61717;background-color:#e3d2d2">，&lt;/span>false表示失败&lt;span style="color:#a61717;background-color:#e3d2d2">，&lt;/span>如果失败value的值为nil&lt;span style="color:#a61717;background-color:#e3d2d2">。&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>指针不能进行偏移和运算&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数变量：类型为func([参数类型] [,参数类型……])[返回类型]&lt;/p>
&lt;p>函数变量常常用于搭配匿名函数接收回调函数，&lt;strong>使用了回调函数，可以增加灵活性（具体函数由调用主体实现，被调用者只用函数变量来接收参数）&lt;/strong>&lt;/p>
&lt;p>e.g:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#228b22">// 遍历切片的每个元素, 通过给定函数进行元素访问
&lt;/span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">visit&lt;/span>(list []&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>, f &lt;span style="color:#8b008b;font-weight:bold">func&lt;/span>(&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>)) {
&lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> _, v := &lt;span style="color:#8b008b;font-weight:bold">range&lt;/span> list {
&lt;span style="color:#008b45">f&lt;/span>(v)
}
}
&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">main&lt;/span>() {
&lt;span style="color:#228b22">// 使用匿名函数打印切片内容
&lt;/span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#008b45">visit&lt;/span>([]&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>{&lt;span style="color:#b452cd">1&lt;/span>, &lt;span style="color:#b452cd">2&lt;/span>, &lt;span style="color:#b452cd">3&lt;/span>, &lt;span style="color:#b452cd">4&lt;/span>}, &lt;span style="color:#8b008b;font-weight:bold">func&lt;/span>(v &lt;span style="color:#00688b;font-weight:bold">int&lt;/span>) {
fmt.&lt;span style="color:#008b45">Println&lt;/span>(v)
})
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>interface{}空接口类型能够接受任意类型变量，因为interface{}不包含任何函数，所以任何类型都实现了空接口，interface的底层实际上是eface结构体&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> eface &lt;span style="color:#8b008b;font-weight:bold">struct&lt;/span>{
_type *_type
data unsafe.Pointer
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="项目目录说明">项目目录说明&lt;/h2>
&lt;blockquote>
&lt;p>src：用于以包（package）的形式组织并存放 Go 源文件，这里的包与 src 下的每个子目录是一一对应。例如，若一个源文件被声明属于 log 包，那么它就应当保存在 src/log 目录中。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>同一个目录下所有的go文件只能有一个包名（package相同）,&lt;strong>但是包名可以与目录名不同（最好是建议相同）&lt;/strong>&lt;/li>
&lt;li>main 包是Go语言程序的入口包，main函数是入口函数，只有package main的go文件能包含main函数（&lt;strong>有且仅有一个&lt;/strong>），一个Go语言程序必须&lt;strong>有且仅有一个&lt;/strong> main 包。如果一个程序没有 main 包，那么编译时将会出错，无法生成可执行文件&lt;/li>
&lt;li>&lt;strong>使用大小写来决定常量，变量，函数等是否可以被外部包所使用，首字母大写就相当于public，首字母小写就相当于private&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="条件循环语句">条件，循环语句&lt;/h2>
&lt;p>&lt;strong>if 语句使用 tips&lt;/strong>&lt;/p>
&lt;p>&lt;strong>（1）&lt;/strong> 不需使用括号将条件包含起来&lt;/p>
&lt;p>&lt;strong>（2）&lt;/strong> &lt;strong>大括号{}必须存在，即使只有一行语句&lt;/strong>&lt;/p>
&lt;p>&lt;strong>（3）&lt;/strong> &lt;strong>左括号必须在if或else的同一行，if的右括号要与else同一行（或者有多个else if的话）&lt;/strong>&lt;/p>
&lt;p>&lt;strong>（4）&lt;/strong> &lt;strong>在if之后，条件语句之前，可以添加变量初始化语句，使用；进行分隔&lt;/strong>&lt;/p>
&lt;p>&lt;strong>（5）&lt;/strong> 在有返回值的函数中，最终的return不能在条件语句中&lt;/p>
&lt;p>&lt;strong>for&lt;/strong>&lt;/p>
&lt;p>&lt;strong>（1）&lt;/strong> 不需要使用括号&lt;/p>
&lt;p>&lt;strong>（2）&lt;/strong> 没有while语句，for condition {}相当于while，for{}相当于while(1)&lt;/p>
&lt;p>&lt;strong>switch&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#8b008b;font-weight:bold">var&lt;/span> a = &lt;span style="color:#cd5555">&amp;#34;hello&amp;#34;&lt;/span>
&lt;span style="color:#8b008b;font-weight:bold">switch&lt;/span> a {
&lt;span style="color:#8b008b;font-weight:bold">case&lt;/span> &lt;span style="color:#cd5555">&amp;#34;hello&amp;#34;&lt;/span>,&lt;span style="color:#cd5555">&amp;#34;cello&amp;#34;&lt;/span>:
fmt.&lt;span style="color:#008b45">Println&lt;/span>(&lt;span style="color:#b452cd">1&lt;/span>)
&lt;span style="color:#8b008b;font-weight:bold">case&lt;/span> &lt;span style="color:#cd5555">&amp;#34;world&amp;#34;&lt;/span>:
fmt.&lt;span style="color:#008b45">Println&lt;/span>(&lt;span style="color:#b452cd">2&lt;/span>)
&lt;span style="color:#8b008b;font-weight:bold">default&lt;/span>:
fmt.&lt;span style="color:#008b45">Println&lt;/span>(&lt;span style="color:#b452cd">0&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>（1）&lt;strong>case与case是独立的代码块，不需要break&lt;/strong>&lt;/p>
&lt;p>（2）case的判断可以是表达式也可以多值，如上所示&lt;/p>
&lt;p>&lt;strong>type-switch&lt;/strong>&lt;/p>
&lt;p>用来判断接口变量的类型&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#8b008b;font-weight:bold">switch&lt;/span> 接口变量.(&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span>) {
&lt;span style="color:#8b008b;font-weight:bold">case&lt;/span> 类型1:
&lt;span style="color:#228b22">// 变量是类型1时的处理
&lt;/span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">case&lt;/span> 类型2:
&lt;span style="color:#228b22">// 变量是类型2时的处理
&lt;/span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#a61717;background-color:#e3d2d2">…&lt;/span>
&lt;span style="color:#8b008b;font-weight:bold">default&lt;/span>:
&lt;span style="color:#228b22">// 变量不是所有case中列举的类型时的处理
&lt;/span>&lt;span style="color:#228b22">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>是某个case的类型就匹配，否则匹配default&lt;/p>
&lt;p>&lt;strong>select&lt;/strong>&lt;/p>
&lt;p>结构类似switch，但是如果有多个case匹配，switch是顺序执行，select是随机执行，&lt;strong>只能用于通道的读写&lt;/strong>&lt;/p>
&lt;p>&lt;strong>break和continue&lt;/strong>&lt;/p>
&lt;p>go中的break有一项功能，就是可以跳到指定标签的循环，例如：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">OuterLoop:&lt;span style="color:#228b22">//我这里给最外层循环打上了OuterLoop的标签
&lt;/span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> i := &lt;span style="color:#b452cd">0&lt;/span>; i &amp;lt; &lt;span style="color:#b452cd">2&lt;/span>; i++ {
&lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> j := &lt;span style="color:#b452cd">0&lt;/span>; j &amp;lt; &lt;span style="color:#b452cd">5&lt;/span>; j++ {
&lt;span style="color:#8b008b;font-weight:bold">switch&lt;/span> j {
&lt;span style="color:#8b008b;font-weight:bold">case&lt;/span> &lt;span style="color:#b452cd">2&lt;/span>:
fmt.&lt;span style="color:#008b45">Println&lt;/span>(i, j)
&lt;span style="color:#8b008b;font-weight:bold">break&lt;/span> OuterLoop&lt;span style="color:#228b22">//这里就不是跳出内层循环了，而是直接跳出最外层循环
&lt;/span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">case&lt;/span> &lt;span style="color:#b452cd">3&lt;/span>:
fmt.&lt;span style="color:#008b45">Println&lt;/span>(i, j)
&lt;span style="color:#8b008b;font-weight:bold">break&lt;/span> OuterLoop
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>continue同理，跳到指定标签循环的下一次循环&lt;/p>
&lt;h2 id="函数">函数&lt;/h2>
&lt;pre>&lt;code>func function_name( [parameter list] ) [return_types] {
函数体
}
&lt;/code>&lt;/pre>&lt;p>函数可以返回多值&lt;/p>
&lt;ul>
&lt;li>未定义长度的数组只能传给不限制数组长度的函数，定义了长度的数组只能传给限制了相同数组长度的函数&lt;/li>
&lt;/ul>
&lt;p>匿名函数&lt;/p>
&lt;ul>
&lt;li>匿名函数就是没有定义函数名的函数，可以传给函数变量&lt;/li>
&lt;/ul>
&lt;p>闭包(closure)&lt;/p>
&lt;ul>
&lt;li>闭包通常是函数内部的匿名函数，在匿名函数中直接使用此函数的局部变量，该局部变量的生命周期会一直跟随着这个匿名函数&lt;/li>
&lt;/ul>
&lt;p>defer（延迟执行语句）&lt;/p>
&lt;ul>
&lt;li>延迟调用函数是&lt;strong>在 defer 所在函数结束前进行，return后进行&lt;/strong>。常使用在释放资源时，比如关闭文件，解锁等等。如果有多个defer，依次逆序调用&lt;/li>
&lt;/ul>
&lt;p>接口型函数&lt;/p>
&lt;ul>
&lt;li>
&lt;p>接口型函数在大量开源go项目中使用到，参考：https://geektutu.com/post/7days-golang-q1.html，简单就是说，一个接口&lt;strong>只有一个方法&lt;/strong>，而定义一个函数实现这个接口（&lt;strong>参数类型都要和接口中的方法的参数类型相同&lt;/strong>，然后实现时调用自己）。这样，就可以拿接口作为函数参数，既可以传入实现了接口的结构体（结构体可以增加自己的方法扩充接口的功能），也可以传入接口型函数（需要强制类型转换），而不单单只是原来定义了一个回调函数参数让用户实现。e.g:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#228b22">// A Getter loads data for a key.
&lt;/span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> Getter &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> {
&lt;span style="color:#008b45">Get&lt;/span>(key &lt;span style="color:#00688b;font-weight:bold">string&lt;/span>) ([]&lt;span style="color:#00688b;font-weight:bold">byte&lt;/span>, &lt;span style="color:#00688b;font-weight:bold">error&lt;/span>)
}
&lt;span style="color:#228b22">// A GetterFunc implements Getter with a function.
&lt;/span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> GetterFunc &lt;span style="color:#8b008b;font-weight:bold">func&lt;/span>(key &lt;span style="color:#00688b;font-weight:bold">string&lt;/span>) ([]&lt;span style="color:#00688b;font-weight:bold">byte&lt;/span>, &lt;span style="color:#00688b;font-weight:bold">error&lt;/span>)
&lt;span style="color:#228b22">// Get implements Getter interface function
&lt;/span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> (f GetterFunc) &lt;span style="color:#008b45">Get&lt;/span>(key &lt;span style="color:#00688b;font-weight:bold">string&lt;/span>) ([]&lt;span style="color:#00688b;font-weight:bold">byte&lt;/span>, &lt;span style="color:#00688b;font-weight:bold">error&lt;/span>) {
&lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> &lt;span style="color:#008b45">f&lt;/span>(key)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="数组和切片">数组和切片&lt;/h2>
&lt;p>切片就是动态数组，可以动态扩展容量，无需指定大小，它有三个元素：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>一个指针指向切片的开始位置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Len，切片的实际长度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cap，最大长度，预分配内存大小&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>切片如果改变元素是会对所有引用及原数组改变的，因为他实际是一个指针&lt;/strong>&lt;/p>
&lt;p>数组初始化方法，例： arr := [3]int{3,4,5}（&lt;strong>数组大小必须固定&lt;/strong>），[&amp;hellip;]type可以根据初始化的个数来判断大小&lt;/p>
&lt;p>切片初始化方法，例：arr := []int{3,4,5}（没指定大小）&lt;/p>
&lt;h3 id="数组中取元素给切片或切片元素给其他切片">数组中取元素给切片(或切片元素给其他切片)&lt;/h3>
&lt;p>比如有一个数组a，他是[n]int型数组&lt;/p>
&lt;p>a[x:y]表示：从a[x]取起到a[y-1]，x为开始索引，y为结束索引（取到y-1）&lt;/p>
&lt;p>不填x和y，默认第一个为0，第二个为n&lt;/p>
&lt;ul>
&lt;li>a[:]，同等a[0:n]，即获取a中所有元素&lt;/li>
&lt;li>a[x:]从a&lt;input checked="" disabled="" type="checkbox"> 取起到a[n]&lt;/li>
&lt;li>a[:y]从a[0]开始取其到a[y-1]&lt;/li>
&lt;li>a[0:0]切片清空&lt;/li>
&lt;/ul>
&lt;h3 id="创建切片的方法">创建切片的方法&lt;/h3>
&lt;p>&lt;strong>创建新切片&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>普通方法创建：&lt;/p>
&lt;p>&lt;code>var arr []int&lt;/code>，切片为nil，无元素&lt;/p>
&lt;/li>
&lt;li>
&lt;p>make函数创建（初始化切片元素到len的元素为0）：&lt;/p>
&lt;p>&lt;code>slice1 := make([]type, len,[cap])&lt;/code>，容量cap可限定也可无限扩展，cap表示预分配内存大小，降低多次分配空间造成的影响&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>引用原数组或原切片的一部分&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>引用另一个数组的一部分：&lt;/p>
&lt;p>s := arr[start:end],即引用原数组或原切片start到end-1的元素&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="切片中追加元素">切片中追加元素&lt;/h3>
&lt;p>切片追加元素用append(切片名，元素)，如果超过cap，cap会翻倍增加&lt;/p>
&lt;p>&lt;strong>tips:&lt;/strong>(&amp;rdquo;&amp;hellip;&amp;ldquo;三个点表示任意参数)&lt;/p>
&lt;p>&lt;strong>使用 slice&amp;hellip;表示slice中的所有元素，方便用于append&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">slice1=&lt;span style="color:#658b00">append&lt;/span>(slice1,slice2...) &lt;span style="color:#228b22">//slice2中的元素一个个追加入slice1中，这样不用一个个写出来了
&lt;/span>&lt;span style="color:#228b22">&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="切片复制">切片复制&lt;/h3>
&lt;p>&lt;code>copy( destSlice, srcSlice)&lt;/code>，从源切片（可以是部分）拷贝到目标切片&lt;/p>
&lt;h3 id="切片删除元素">切片删除元素&lt;/h3>
&lt;ol>
&lt;li>直接移动头指针&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">a = []&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>{&lt;span style="color:#b452cd">1&lt;/span>, &lt;span style="color:#b452cd">2&lt;/span>, &lt;span style="color:#b452cd">3&lt;/span>}
a = a[&lt;span style="color:#b452cd">1&lt;/span>:] &lt;span style="color:#228b22">// 删除开头1个元素
&lt;/span>&lt;span style="color:#228b22">&lt;/span>a = a[N:] &lt;span style="color:#228b22">// 删除开头N个元素
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>原地append（元素前移法）&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">a = []&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>{&lt;span style="color:#b452cd">1&lt;/span>, &lt;span style="color:#b452cd">2&lt;/span>, &lt;span style="color:#b452cd">3&lt;/span>}
a = &lt;span style="color:#658b00">append&lt;/span>(a[:&lt;span style="color:#b452cd">0&lt;/span>], a[&lt;span style="color:#b452cd">1&lt;/span>:]...) &lt;span style="color:#228b22">// 删除开头1个元素（把第1个截掉，后面元素追加上来）
&lt;/span>&lt;span style="color:#228b22">&lt;/span>a = &lt;span style="color:#658b00">append&lt;/span>(a[:&lt;span style="color:#b452cd">0&lt;/span>], a[N:]...) &lt;span style="color:#228b22">// 删除开头N个元素
&lt;/span>&lt;span style="color:#228b22">&lt;/span>
a = &lt;span style="color:#658b00">append&lt;/span>(a[:i], a[i+&lt;span style="color:#b452cd">1&lt;/span>:]...) &lt;span style="color:#228b22">// 删除中间1个元素（截到中间那个元素前，然后把中间后面的元素追加上来）
&lt;/span>&lt;span style="color:#228b22">&lt;/span>a = &lt;span style="color:#658b00">append&lt;/span>(a[:i], a[i+N:]...) &lt;span style="color:#228b22">// 删除中间N个元素
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="range和for-each循环">range和for-each循环&lt;/h2>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> key, value := &lt;span style="color:#8b008b;font-weight:bold">range&lt;/span> 数组或切片或map {
代码块
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用range可以搭配for循环遍历数组、切片、map和字符串等，以key-value的形式返回（数组和切片的key是索引值），如果不需要key或者value可以用__占位符替代。使用range还可以搭配可变参数，e.g:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">myfunc&lt;/span>(args ...&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>) {
&lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> _, arg := &lt;span style="color:#8b008b;font-weight:bold">range&lt;/span> args {
fmt.&lt;span style="color:#008b45">Println&lt;/span>(arg)
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可变参数实际上就是一个切片，并且可以用&lt;code>args...&lt;/code>继续传给其他函数&lt;/p>
&lt;p>&lt;strong>tips:&lt;/strong>&lt;/p>
&lt;p>&lt;strong>需要注意的是，value为值的拷贝，所以只具有可读性，对这个value值的改变不会改变原来集合中的值&lt;/strong>&lt;/p>
&lt;h2 id="map">Map&lt;/h2>
&lt;h3 id="创建map">创建map&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;code>var 变量名 map[key_type]value_type&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用make函数创建：&lt;/p>
&lt;p>&lt;code>变量名 := make(map[key_type]value_type,[cap])&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>tips:&lt;/strong>&lt;/p>
&lt;p>&lt;strong>value_type可以是切片，这样一个key就对应多个value值了，例如：父进程的pid作为key，多个子进程的pid作为切片元素&lt;/strong>&lt;/p>
&lt;h3 id="map中追加元素">map中追加元素&lt;/h3>
&lt;p>直接key-value方法赋值即可&lt;/p>
&lt;h3 id="map删除元素">map删除元素&lt;/h3>
&lt;p>&lt;code>delete(map,key)&lt;/code>&lt;/p>
&lt;h2 id="containerlist">container/list&lt;/h2>
&lt;p>实现为双向循环链表&lt;/p>
&lt;p>list为element+len（链表长度，不包括哨兵），element才是具体节点&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gob78fnrlkj315h0m4wht.jpg" alt="IMG_0055">&lt;/p>
&lt;h3 id="创建链表">创建链表&lt;/h3>
&lt;p>&lt;code>变量 := list.New()&lt;/code>，New()返回一个*list，链表无节点，只有哨兵，len为0&lt;/p>
&lt;h3 id="链表中插入元素">链表中插入元素&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">这里head为*list&lt;span style="color:#a61717;background-color:#e3d2d2">，&lt;/span>代表链表的头
尾部插入&lt;span style="color:#a61717;background-color:#e3d2d2">：&lt;/span>head.&lt;span style="color:#008b45">PushBack&lt;/span>(任意类型元素)
前部插入&lt;span style="color:#a61717;background-color:#e3d2d2">：&lt;/span>head.&lt;span style="color:#008b45">PushFront&lt;/span>(任意类型元素)
PushBack和PushFront都返回一个*Element&lt;span style="color:#a61717;background-color:#e3d2d2">，&lt;/span>用来方便在链表中插入节点
这里用mark表示PushBack或PushFront返回的*Element
在mark后插&lt;span style="color:#a61717;background-color:#e3d2d2">：&lt;/span>head.&lt;span style="color:#008b45">InsertAfter&lt;/span>(任意类型元素,mark)
在mark前插&lt;span style="color:#a61717;background-color:#e3d2d2">：&lt;/span>head.&lt;span style="color:#008b45">InsertBefore&lt;/span>(任意类型元素,mark)
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除链表元素">删除链表元素&lt;/h3>
&lt;p>&lt;code>head.Remove(mark)&lt;/code>&lt;/p>
&lt;h3 id="遍历链表元素">遍历链表元素&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> i := l.&lt;span style="color:#008b45">Front&lt;/span>(); i != &lt;span style="color:#8b008b;font-weight:bold">nil&lt;/span>; i = i.&lt;span style="color:#008b45">Next&lt;/span>() {
fmt.&lt;span style="color:#008b45">Println&lt;/span>(i.Value)
}
&lt;span style="color:#228b22">/*
&lt;/span>&lt;span style="color:#228b22">Front()表示获取第一个节点，Back()表是获取最后一个节点，Next()表示下一节点,Value获取节点值
&lt;/span>&lt;span style="color:#228b22">*/&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="指针">指针&lt;/h2>
&lt;p>指针的用法与c语言相同&lt;/p>
&lt;p>也可以用 new()函数来创建指针，例：var_name := new(type)，这样var_name保存的是type类型变量的首地址&lt;/p>
&lt;h2 id="结构体">结构体&lt;/h2>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> 类型名 &lt;span style="color:#8b008b;font-weight:bold">struct&lt;/span> {
字段1 字段1类型
字段2 字段2类型
&lt;span style="color:#a61717;background-color:#e3d2d2">…&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>tips:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>结构体中的字段可以内嵌其他结构体，被内嵌的结构体中的字段可以直接引用，而不用多层引用（有点像继承），e.g:&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>a.b.c.d可以直接用a.d&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>go中指针结构体中的字段可以直接引用（用了语法糖），而不用像C中一样用-&amp;gt;&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="结构体实例化方式">结构体实例化方式&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>以创建指针的方式&lt;/p>
&lt;p>&lt;code>ins := new(T)&lt;/code>&lt;/p>
&lt;p>其中T为结构体类型名，返回一个*T&lt;/p>
&lt;/li>
&lt;li>
&lt;p>取结构体的地址实例化&lt;/p>
&lt;p>&lt;code>ins := &amp;amp;T{}&lt;/code>&lt;/p>
&lt;p>同样返回一个*T，然后&lt;code>T.字段名&lt;/code>赋值，或者&lt;strong>指明字段的方式&lt;/strong>&lt;/p>
&lt;pre>&lt;code>ins := &amp;amp;结构体类型名{
字段1: 字段1的值,
字段2: 字段2的值,
…
}
&lt;/code>&lt;/pre>&lt;p>字段与字段之间用,分隔，这种方式某个字段可以省略，那么字段值取省略值&lt;/p>
&lt;p>或者&lt;strong>多值方式&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">ins := &amp;amp;结构体类型名{
字段1的值,
字段2的值,
&lt;span style="color:#a61717;background-color:#e3d2d2">…&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种方式省略字段名，但是所有结构体内的字段都必须赋值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>直接定义&lt;/p>
&lt;p>声明方式也是&lt;strong>指明字段和多值方式&lt;/strong>，只不过变量用的是T而不是*T而已&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="接口">接口&lt;/h2>
&lt;p>go中的接口是非侵入式的，不同于Java这些语言需要显式的进行implements接口，go类型实现接口不需要进行声明，只需要实现接口中的所有方法，所以类型中的方法是接口中方法的&lt;strong>超集&lt;/strong>。非侵入式的好处还在于，不同于面向对象接口需要根据业务来事先制定接口中的方法，&lt;strong>甚至可以先实现类型再声明接口&lt;/strong>，可扩展性强，而且如果以后想把接口中一些方法独立出来列为新接口，按照Java这些侵入式的方法，是需要重新implements新接口并且重新编译的。&lt;strong>而且，类型实现接口甚至不需要引入包&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> 接口类型名 &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span>{
方法名1( 参数列表1 ) 返回值列表1
方法名2( 参数列表2 ) 返回值列表2
&lt;span style="color:#a61717;background-color:#e3d2d2">…&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>参数&lt;strong>名&lt;/strong>和返回值&lt;strong>名&lt;/strong>都可以省略&lt;/p>
&lt;h3 id="实现接口">实现接口&lt;/h3>
&lt;p>e.g:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#228b22">// 定义一个数据写入器
&lt;/span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> DataWriter &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> {
&lt;span style="color:#008b45">WriteData&lt;/span>(data &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span>{}) &lt;span style="color:#00688b;font-weight:bold">error&lt;/span>
}
&lt;span style="color:#228b22">// 定义文件结构，用于实现DataWriter
&lt;/span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> file &lt;span style="color:#8b008b;font-weight:bold">struct&lt;/span> {
}
&lt;span style="color:#228b22">// 实现DataWriter接口的WriteData方法
&lt;/span>&lt;span style="color:#228b22">// 这里方法要指定接收者
&lt;/span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> (d *file) &lt;span style="color:#008b45">WriteData&lt;/span>(data &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span>{}) &lt;span style="color:#00688b;font-weight:bold">error&lt;/span> {
&lt;span style="color:#228b22">// 模拟写入数据
&lt;/span>&lt;span style="color:#228b22">&lt;/span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(&lt;span style="color:#cd5555">&amp;#34;WriteData:&amp;#34;&lt;/span>, data)
&lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>tips:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>只有当实现了接口的类型赋值给接口变量时，编译器才会去比较这个类型中是否全部实现了接口中的方法&lt;/strong>&lt;/li>
&lt;li>内嵌结构体也能实现接口，这样外层结构体就不必再实现一次了，避免了冗余代码&lt;/li>
&lt;li>实现类型不能是&lt;strong>系统内置类型，只能是结构体或者是用type定义的新类型&lt;/strong>&lt;/li>
&lt;li>接口中可以像结构体一样嵌套接口，这样接口中就拥有被嵌套接口的所有方法了&lt;/li>
&lt;/ul>
&lt;h3 id="error接口">error接口&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> &lt;span style="color:#00688b;font-weight:bold">error&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> {
&lt;span style="color:#008b45">Error&lt;/span>() &lt;span style="color:#00688b;font-weight:bold">string&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果要自定义error可以实现Error()方法，返回错误信息，打印error默认调用的是error.Error()&lt;/p>
&lt;p>errors包中的errors.New(&amp;ldquo;错误信息&amp;rdquo;)就是返回一个error对象&lt;/p>
&lt;p>文章推荐：关于interface的十个问题，解析interface的一些机制和底层实现：https://mp.weixin.qq.com/s/EbxkBokYBajkCR-MazL0ZA&lt;/p>
&lt;h2 id="宕机panic和宕机恢复recover">宕机(panic)和宕机恢复(recover)&lt;/h2>
&lt;p>&lt;strong>Go语言没有异常系统，其使用 panic 触发宕机类似于其他语言的抛出异常（打印堆栈和信息），recover 的宕机恢复机制就对应其他语言中的 try/catch 机制。&lt;/strong>&lt;/p>
&lt;p>panic()和recover()都为内置函数&lt;/p>
&lt;p>如果当前的 goroutine 陷入panic，调用 recover 可以捕获到 panic 的输入值，并且恢复正常的执行。&lt;/p>
&lt;p>&lt;strong>因为如果在手动panic前声明的defer会执行，所以可以将recover放到defer中，用于恢复，相当于Java中的catch，try中发生错误，直接将控制交给catch&lt;/strong>&lt;/p>
&lt;p>e.g:&lt;/p>
&lt;p>web服务器崩溃时用recover关闭连接，或者向客户端传递异常信息用于调试&lt;/p>
&lt;h2 id="sort包">Sort包&lt;/h2>
&lt;h3 id="排序">排序&lt;/h3>
&lt;p>如果要对切片元素进行自定义排序，需要实现sort.Interface接口中的三个方法：&lt;/p>
&lt;ol>
&lt;li>​ Len() int // 获取元素数量&lt;/li>
&lt;li>​ Less(i, j int) bool // i，j是序列元素的指数。&lt;strong>即表示怎么样算一个元素小于另一个元素，由自己实现&lt;/strong>&lt;/li>
&lt;li>​ Swap(i, j int) // 交换元素&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>注意，系统内置变量是不能够用来实现接口的，必须用type声明新类型&lt;/strong>&lt;/p>
&lt;p>sort包中内置了一些切片，这些切片已经实现了Interface中的方法，&lt;strong>所以直接用这些切片定义，并用sort.Sort方法即可排序&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gob78l1bnmj31060aoq4k.jpg" alt="image-20201222154656587">&lt;/p>
&lt;p>如果是针对于结构体想进行排序就要针对于某个字段写Less方法了&lt;/p>
&lt;p>&lt;strong>这里推荐sort包中更快的实现方式&lt;/strong>，sort.Slice方法，这样就不必实现sort.Interface中所有方法，直接提供一个切片和回调函数就行了（就是提供一个Less()函数，怎么比较切片中元素的大小）&lt;/p>
&lt;p>&lt;code>func Slice(slice interface{}, less func(i, j int) bool)&lt;/code>&lt;/p>
&lt;h3 id="查找">查找&lt;/h3>
&lt;p>sort.Search(n int, f func(i int) bool) int&lt;/p>
&lt;p>利用二分查找返回f(i)==true时最小的索引值，f是用户提供的回调函数，当[0,i)时f为false，&amp;gt;=i时f为true，通常是搜索array或者slice时使用，n传入len(arrry或者slice)&lt;/p>
&lt;h2 id="goroutine核心">goroutine（核心）&lt;/h2>
&lt;p>参考资料：https://www.cnblogs.com/wdliu/p/9272220.html&lt;/p>
&lt;p>goroutine相当于类线程，不同于其他语言线程之间是通过共享内存的方式来通信，&lt;strong>go中的goroutine是通过通道来相互传递消息的&lt;/strong>&lt;/p>
&lt;p>goroutine和内核级线程的对应关系是&lt;strong>多对多&lt;/strong>关系，如果机器为多核机器，goroutine就可以并行执行&lt;/p>
&lt;p>&lt;strong>使用方法&lt;/strong>：&lt;/p>
&lt;p>&lt;strong>go 函数名(实参)即可运行一个goroutine&lt;/strong>&lt;/p>
&lt;h3 id="mpg模型">MPG模型&lt;/h3>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;ul>
&lt;li>M:M代表内核级线程，一个M就是一个线程；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。&lt;strong>M一定要和一个P绑定&lt;/strong>&lt;/li>
&lt;li>G:代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调度。&lt;/li>
&lt;li>P:P全称是Processor，处理器，它的主要用途就是用来执行goroutine的，所以它也维护了一个自己的&lt;strong>local goroutine队列&lt;/strong>，里面存储了所有需要它来执行的goroutine。当然还存在一个&lt;strong>全局的global goroutine队列&lt;/strong>，如果local队列中的goroutine运行完了也会取global队列中的goroutine来运行&lt;/li>
&lt;li>Sched：代表调度器，负责将goroutine调度到具体某个队列中（可以是新的goroutine加入，或者是从其他队列中取得的goroutine(work stealing机制））&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>goroutine理想调度流程&lt;/strong>：&lt;/p>
&lt;p>当通过&lt;code>go&lt;/code>关键字创建一个新的goroutine的时候，它会优先被放入P的本地队列。为了运行goroutine，M需要持有（绑定）一个P，接着M会启动一个OS线程，循环从P的本地队列里取出一个goroutine并执行。当然还有 &lt;code>work-stealing&lt;/code>调度算法：当M执行完了当前P的Local队列里的所有G后，P也不会就这么在那躺尸啥都不干，它会先尝试从Global队列寻找G来执行，如果Global队列为空，它会随机挑选另外一个P，从它的队列里中拿走一半的G到自己的队列中执行（不能让自己闲置起来）&lt;/p>
&lt;p>参考资料：https://zhuanlan.zhihu.com/p/37754274&lt;/p>
&lt;h3 id="channel通道">channel通道&lt;/h3>
&lt;p>通道是一种双向的管道，用于goroutine间的信息交换（传输变量，结构体，指针等等）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>无缓冲管道：&lt;/p>
&lt;p>ch := make(chan 类型)&lt;/p>
&lt;p>发送方向通道发送数据后，若没有接收方取数据就会阻塞，直到接收方接收为止；接收方同理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有缓冲管道：&lt;/p>
&lt;p>ch := make(chan 类型，缓冲区大小)&lt;/p>
&lt;p>不同于无缓冲的情况，发送方可以不用阻塞地一直向管道发送数据，直到缓冲区满之后才会阻塞；接收方也可以不用阻塞地从通道中取数据（当然是缓冲区中有数据的情况），直到没有数据可取为止，则接收方阻塞&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>空结构体通道&lt;/strong>&lt;/p>
&lt;p>因为空结构体struct{}不占内存，所以可以用来作为信号来同步，当一个goroutine完成时，可以通过发送struct{}{}表示已完成，通知另一端的goroutine&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="关闭通道">关闭通道&lt;/h4>
&lt;p>使用原语close(chan)关闭通道，读取关闭的通道会读取到相应类型的&lt;strong>零值&lt;/strong>&lt;/p>
&lt;h3 id="context">Context&lt;/h3>
&lt;p>context可以用来goroutine之间进行&lt;strong>元数据传递或者退出通知（从ctx.Done()当中读出，节省资源）或者防止goroutine泄漏&lt;/strong>等操作，参考：https://zhuanlan.zhihu.com/p/68792989&lt;/p>
&lt;h3 id="syncwaitgroup">sync.WaitGroup&lt;/h3>
&lt;p>有时候主线程需要等待其他goroutine执行完毕，用time.Sleep的方法不太好，无法估计所有goroutine完成的时间，所以用sync.WaitGroup结构体来做同步比较好&lt;/p>
&lt;p>方法：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Add(delta int)&lt;/p>
&lt;p>delta表示要执行的goroutine数量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Done()&lt;/p>
&lt;p>sync.WaitGroup变量调用一次Done()，结构体中的计数器（delta数）就-1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Wait()&lt;/p>
&lt;p>一直阻塞，直到计数器变为0为止，可以放在main函数的最后，等待所有其他goroutine done，然后结束程序&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="互斥锁和读写互斥锁">互斥锁和读写互斥锁&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>互斥锁&lt;/p>
&lt;p>sync.Mutex，对等操作系统里学的mutex&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读写互斥锁&lt;/p>
&lt;p>sync.RWMutex，封装了Mutex，还内置读者计数器，可用于单写者多读者，效率比普通互斥锁要高&lt;/p>
&lt;/li>
&lt;/ul>
- https://jessestutler.github.io/posts/golang%E5%9F%BA%E7%A1%80/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Docker底层原理</title><link>https://jessestutler.github.io/posts/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</link><pubDate>Sun, 07 Mar 2021 11:12:39 +0800</pubDate><guid>https://jessestutler.github.io/posts/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ -&lt;h1 id="docker底层原理">docker底层原理&lt;/h1>
&lt;h2 id="namespace资源隔离">namespace——资源隔离&lt;/h2>
&lt;p>namespace 是 Linux 内核用来隔离内核资源的方式，同一个namespace中的进程之间可以互相感知，不同namespace之间的进程是相互独立的，&lt;strong>docker本身就是一个进程，通过namespace来实现隔离，从而模拟独立运行环境&lt;/strong>，在/proc/$$/ns下能查看当前进程下的所有link文件，每个link文件对应不同的namespace，&lt;strong>如果不同的进程间有相同的namespace的inode号，则他们是共享namespace的&lt;/strong>，否则他们属于不同的的namespace&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gob6e80y1pj30i904dglp.jpg" alt="img">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>**通过clone()函数在创建子进程的同时给子进程创建新的namespace（传入CLONE_*宏定义）**&lt;/p>
&lt;/li>
&lt;li>
&lt;p>UTS namespace：&lt;/p>
&lt;p>提供&lt;strong>主机名和域名&lt;/strong>的隔离，使容器能够通过服务名访问&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IPC namespace（进程间通信）：&lt;/p>
&lt;p>实现&lt;strong>信号量、消息队列和共享内存等资源&lt;/strong>的隔离&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PID namespace：&lt;/p>
&lt;p>对进程内的PID重新标号，从1开始，每个PID namespace都有自己的计数程序，宿主机的PID namespace相当于创建进程的PID namespace的parent pid namespace，能看到子节点（child pid namespace)中的内容，但子节点不能看到父节点当中的内容，这样父节点能在外部管理容器内的进程&lt;/p>
&lt;p>如果pid namespace中的某个进程的父进程被杀死，该进程成为孤儿进程，则&lt;strong>会被当前pid namespace的init进程（pid为1，如/bin/bash）收养，成为其子进程&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mount namespace:&lt;/p>
&lt;p>通过隔离文件系统挂载点来隔离文件系统（当创建新的mount namespace时，会将所有挂载点复制给子进程，但在这之后，子进程对自己namespace内文件系统进行的操作不会影响到父进程namespace）&lt;/p>
&lt;p>&lt;strong>可以通过共享挂载机制传播挂载（主从挂载、共享挂载等）&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>network namespace:&lt;/p>
&lt;p>提供网络资源的隔离，包括网络设备、协议栈、路由表、防火墙等等&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://images2018.cnblogs.com/blog/1259802/201804/1259802-20180410165500455-232801094.jpg" alt="img">&lt;/p>
&lt;p>&lt;strong>默认的bridge模式&lt;/strong>：&lt;/p>
&lt;p>每个容器有独立的network namespace，宿主机通过docker0网桥（虚拟网桥）来连接不同的network namespace，容器通过veth pair（虚拟以太网端口对，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来）连接docker0网桥，设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名。&lt;/p>
&lt;p>如果容器想主动和外界通信，或者外界想访问容器内的服务（访问宿主机的端口），实际上这是通过iptables来管理的（进行了转发和NAT转换等操作）&lt;/p>
&lt;p>&lt;strong>host模式：&lt;/strong>&lt;/p>
&lt;p>容器和宿主机共享network namespace，但其他namespace与宿主机隔离，容器用的是宿主机的ip与外界通信，性能较好但易产生端口冲突&lt;/p>
&lt;p>&lt;strong>container模式：&lt;/strong>&lt;/p>
&lt;p>新创建的容器若指定container模式，则和已经存在的容器共享一个network namespace，与此容器共享ip和协议栈&lt;/p>
&lt;ul>
&lt;li>
&lt;p>user namespace&lt;/p>
&lt;p>提供安全隔离，比如用户id，用户组，权限等，在子进程的user namespace中拥有新的用户和用户组，在父进程中的普通用户可能却成为子进程中namespace的超级用户，结构与pid namespace类似（树状结构），&lt;strong>子user namespace中的用户和用户组需要与父user namespace中的用户和用户组相对应（做映射）&lt;/strong>，这样这个user namespace才能与其他user namespace中的进程通信，甚至访问共享的文件（即对应到其他user namespace的用户和用户组并拥有相应的权限，如果没有相应的权限就不能在其他user namespace执行某些操作）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="cgroups资源限制">cgroups——资源限制&lt;/h2>
&lt;p>cgroups 是Linux内核提供的一种&lt;strong>可以限制单个进程或者多个进程所使用资源&lt;/strong>的机制，可以对 cpu，内存等资源实现精细化的控制（使用上限，使用范围等等），cgroup通过伪文件系统的形式进行控制&lt;/p>
&lt;p>&lt;strong>涉及概念：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>task（任务）：表示系统的一个进程或线程&lt;/p>
&lt;/li>
&lt;li>
&lt;p>subsystem(子系统)：每个子系统就是一个资源控制器，有cpu、memory、io等等，/sys/fs/cgroup/下的目录就代表每个子系统&lt;/p>
&lt;/li>
&lt;li>
&lt;p>hierarchy（层级）：层级由一系列的cgroup以一个树状形式组成，由一个或多个子系统限制层级的资源使用量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>cgroup&lt;/strong>（控制组）：核心概念，由cgroup组成层级，task放在cgroup中，从而控制进程的使用资源量，docker的实现方法就是在每个子系统中为每个容器创建cgroup&lt;/p>
&lt;p>ps:笔者自己ipad画的图，有点简陋抱歉:P，以后文章的图有时间都会用Graffle好好画一下&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8pmb9h1aj30xg0pdq97.jpg" alt="image-20201104214438717">&lt;/p>
&lt;h2 id="docker-架构总览">docker 架构总览&lt;/h2>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gob68s57bpj311c0hm7ax.jpg" alt="image-20201209104859776">&lt;/p>
&lt;h3 id="runc">runC&lt;/h3>
&lt;p>是对于OCI标准的一个参考实现，是一个可以用于创建和运行容器的CLI(command-line interface)工具。runc直接与容器所依赖的cgroup/linux kernel等进行交互，负责为容器配置cgroup/namespace等启动容器所需的环境，创建启动容器的相关进程。runC基本上就是一个命令行小工具，它可以不用通过Docker引擎，直接就可以创建容器。这是一个独立的二进制文件，使用OCI容器就可以运行它。&lt;/p>
&lt;h3 id="containerd">containerd&lt;/h3>
&lt;p>containerd 是一个守护进程，它可以使用runC管理容器，并使用gRPC暴露容器的其他功能。docker engine面向client，containerd暴露出针对容器的增删改查的接口，Docker engine通过gRPC调用这些接口完成对于容器的操作，containerd最后会通过runc来实际运行容器。&lt;/p>
&lt;h3 id="containerd-shim">containerd-shim&lt;/h3>
&lt;p>containerd-shim称之为垫片，它使用runC命令行工具完成容器的启动、停止以及容器运行状态的监控。containerd-shim进程由containerd进程拉起，并持续存在到容器实例进程退出为止（和容器进程同生命周期）。这种设计的优点是，只要是符合OCI规范的容器，都可以通过containerd-shim来进行调用&lt;/p>
&lt;h2 id="联合文件系统">联合文件系统&lt;/h2>
&lt;p>&lt;img src="https://docs.docker.com/storage/storagedriver/images/container-layers.jpg" alt="Layers of a container based on the Ubuntu image">&lt;/p>
&lt;p>&lt;strong>如果容器基于同一镜像构建，所有容器共享底部的镜像层，镜像层是read-only的，不可被修改，容器只是在镜像层之上创建了一个读写层，所有容器的修改都是在读写层当中修改，并不会影响到底部的镜像层，当容器删除了，读写层也就跟着删除了（除非commit做成了新的镜像）&lt;/strong>&lt;/p>
&lt;p>&lt;strong>就算容器不是基于同一镜像构建，如果不同镜像中有相同的层（比如FROM是相同的），容器也会读取同一镜像层，这就是联合文件系统的精髓所在，副本只保存一份&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://docs.docker.com/storage/storagedriver/images/sharing-layers.jpg" alt="Containers sharing same image">&lt;/p>
&lt;h2 id="copy-on-writecow机制">Copy on write（COW）机制&lt;/h2>
&lt;p>&lt;strong>当容器需要读取文件的时候&lt;/strong>&lt;/p>
&lt;p>从最上层镜像开始查找，往下找，找到文件后读取并放入内存，若已经在内存中了，直接使用。(即，同一台机器上运行的docker容器共享运行时相同的文件)。&lt;/p>
&lt;p>&lt;strong>当容器需要添加文件的时候&lt;/strong>&lt;/p>
&lt;p>直接在最上面的容器层可写层添加文件，不会影响镜像层。&lt;/p>
&lt;p>&lt;strong>当容器需要修改文件的时候&lt;/strong>&lt;/p>
&lt;p>从上往下层寻找文件，找到后，&lt;strong>复制到容器可写层&lt;/strong>，然后，对容器来说，可以看到的是容器层的这个文件，看不到镜像层里的文件。容器在容器层修改这个文件（也就是覆盖）。&lt;/p>
&lt;p>&lt;strong>如果是一个经常需要写的应用，最好使用volume而不是都写在容器层里，这样不会使容器层变得很大&lt;/strong>&lt;/p>
&lt;p>&lt;strong>当容器需要删除文件的时候&lt;/strong>&lt;/p>
&lt;p>从上往下层寻找文件，找到后在容器中记录删除。即，&lt;strong>并不会真正的删除文件，而是软删除&lt;/strong>。这将导致镜像体积只会增加，不会减少。&lt;strong>所以要写Dockerfile时如果要删除镜像中的文件，最好在同一层删除，否则只是软删除&lt;/strong>（因为如果真正的删除就会导致基于这个镜像构架内的其他容器无法再读取这个文件了）&lt;/p>
&lt;h2 id="iptables默认规则只列举了部分">iptables默认规则（只列举了部分）&lt;/h2>
&lt;ul>
&lt;li>nat表：
&lt;ul>
&lt;li>如果数据源地址是docker0网段地址，且发往除docker 0外端口（即发往主机外），则做SNAT转换，修改为主机网卡ip地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>filter表：
&lt;ul>
&lt;li>docker0发出的包可以中转给docker 0本身，即容器之间可以互相通信&lt;/li>
&lt;li>docker0发出的包可以中转给其他宿主机上的其他网卡&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>《Docker容器与容器云 第2版》浙江大学SEL实验室·著&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/517e757d6d17">https://www.jianshu.com/p/517e757d6d17&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/sparkdev/tag/docker/default.html?page=1">https://www.cnblogs.com/sparkdev/tag/docker/default.html?page=1&lt;/a>&lt;/li>
&lt;/ul>
- https://jessestutler.github.io/posts/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Docker基础知识</title><link>https://jessestutler.github.io/posts/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Sun, 07 Mar 2021 10:56:15 +0800</pubDate><guid>https://jessestutler.github.io/posts/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ -&lt;h1 id="docker">Docker&lt;/h1>
&lt;h2 id="docker拉取镜像流程图">Docker拉取镜像流程图&lt;/h2>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gob5syundsj318o0ogn1v.jpg" alt="截屏2020-08-12 上午10.33.14">&lt;/p>
&lt;h2 id="docker-cli">Docker CLI&lt;/h2>
&lt;h3 id="镜像命令">镜像命令&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;code>docker images 查看本地的镜像&lt;/code>&lt;/p>
&lt;p>docker images [image-name[:tag]]
默认不加参数就是-a，或者指定image的名字，可在image之上再加版本号
&amp;ndash;a 列出所有镜像
&amp;ndash;q [image] 列出镜像的id（-aq是列出所有的镜像id）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>docker search 镜像&lt;/code>&lt;/p>
&lt;p>搜索远程仓库镜像（docker hub上查看更详细）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>docker rmi [repo[:tag]] &lt;/code>&lt;/p>
&lt;p>删除本地镜像，使用方法与images相同，注意rmi是删除镜像，rm是删除容器&lt;/p>
&lt;p>或者根据docker images -q [image]列出的id进行删除&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>docker tag source_image[:tag] target_image[:tag] &lt;/code>&lt;/p>
&lt;p>改镜像标签名（不然默认传到docker hub上的library仓库会被拒绝）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>docker pull 镜像&lt;/code>&lt;/p>
&lt;p>默认拉取的是docker hub上的Image，也可以用一个容器跑一个local docker registry，然后让其他使用了docker pull并指定了docker registry地址和端口的机子从这台运行了docker registry的机子上拉镜像&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>docker push 镜像&lt;/code>&lt;/p>
&lt;p>将镜像上传到docker hub上的仓库或指定仓库&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>docker save -o [tar文件名] [镜像名] &lt;/code>&lt;/p>
&lt;p>用来将镜像保存到tar文件当中，可以指定一个或多个镜像名
也可以使用gzip压缩tar，使用docker save [镜像名] | gzip &amp;gt; [xxx.tar.gz]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>docker load -i [tar文件名或gzip等压缩格式] &lt;/code>&lt;/p>
&lt;p>用来读取文件形成镜像&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="容器命令">容器命令&lt;/h3>
&lt;blockquote>
&lt;p>&lt;strong>docker run 创建容器并运行&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">docker run [选项] 镜像名 [参数]
-it 获取stdin并运行一个伪tty(默认是/bin/bash，可在命令最后自己指定shell)
--name 为容器指定一个名字(最好加上方便些，不然就要根据container id来指示是哪个容器)
最好加上自己docker hub上的repo名，这样可以直接push到自己的repo，而不用tag再改镜像名，如 jesse/centos:tag
-d 后台运行，如果容器没有对外提供服务或运行前台程序则会立刻停止
-p 将容器内的端口与host os的端口绑定起来，如-p host_port:container_port可以通过访问host的某个端口来访问容器内的某个服务
-P 大写P,将镜像指定的暴露端口与host os上的随机端口绑定起来，一般需要Dockerfile中有EXPOSE进行结合
-v 将容器内的某个文件夹与host os的文件夹绑定起来（即数据同步，相当于挂载）
1.如-v host_dir:container_dir 指定路径挂载，可以将容器内的指定文件夹数据同步到host os的指定目录上，这样删除容器时不至于数据丢失（比如容器内装有Mysql，这样删除容器就相当于把整个数据库都删了）
2.如-v volume_name:container_dir 具名挂载，会指定卷名，可以通过docker volume inspect volume_name查看在Host os上的目录位置
--volumes-from 继承已有的容器的数据卷（共享目录）
e.g:
docker run --name centos -it centos /bin/bash
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;strong>docker ps 查看容器&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">不指定参数就是查看正在运行的容器
-a 查看所有容器（包括停止的容器）
-q 列出容器id
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>docker rm [container id 或者 container name] 删除容器&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">不加参数需要指定container id或者container name，正在运行的容器无法删除
-f 强制删除容器
docker ps -aq | xargs docker rm -f 强制删除所有容器
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>docker start 启动容器&lt;/p>
&lt;p>docker restart 重启容器&lt;/p>
&lt;p>docker stop 停止容器&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>docker logs 查看日志&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">-f 实时跟随
-t 显示时间
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>docker top 显示容器内正在运行的进程&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>docker inspect 显示容器的所有&lt;strong>配置信息（元数据）d&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;strong>进入正在运行的容器&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">1.docker &lt;span style="color:#658b00">exec&lt;/span> [container] [command]
在容器里跑一个命令
-it 与docker run相同，获取stdin并进入伪tty
e.g:
docker &lt;span style="color:#658b00">exec&lt;/span> -it [container id或者container name] bash ———— 在容器里跑一个新的bash并进入
2.docker attach [container]
直接进入到container当中
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>docker cp 将容器中的文件拷贝到外部os或将外部os的文件拷贝至容器中&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>docker cp container:path dest_path&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>docker commit 由现有容器制作镜像&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">-a 指定作者名
-m 这次提交要发布的消息
docker commit [选项] container [image[:tag]]
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="卷命令">卷命令&lt;/h3>
&lt;blockquote>
&lt;p>docker volume&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">特别说明：不同的容器可以指定相同的volume
ls 列出所有的卷
inspect 查看指定卷的信息（可查看挂载在host os上具体哪个位置）
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker基本命令图">Docker基本命令图&lt;/h2>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gob60cd4z5j316t0u0k9j.jpg" alt="image-20200812163714285">&lt;/p>
&lt;h2 id="docker层的概念">Docker层的概念&lt;/h2>
&lt;p>&lt;img src="https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1597383379693&amp;amp;di=8a718adcadd59dbfafaf89136bcf6efe&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F2030366%2F202006%2F2030366-20200630103737429-2119801149.png" alt="img">&lt;/p>
&lt;h2 id="dockerfile命令">Dockerfile命令&lt;/h2>
&lt;p>tips:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>命令最好大写，写一个命令代表构建&lt;/p>
&lt;/li>
&lt;li>
&lt;p>选用合适的镜像，不要选用过大的父镜像从而构建出臃肿庞大的镜像，选用小巧的父镜像（如alpine、busybox、debian等）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>使用多阶段构建形式（多个FROM命令，以最后一个FROM为根），例如将编译环境和构建环境分离开来可以避免镜像过大（因为构建环境只需要编译出来的可执行文件，而不需要编译所需的库和命令等一大堆文件）&lt;/strong>&lt;/p>
&lt;p>COPY &amp;ndash;from=指定的阶段名&lt;/p>
&lt;p>可以将指定阶段中编译好的文件拷贝到当前构建环境中，甚至可以从指定镜像中进行拷贝&lt;/p>
&lt;p>e.g:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="color:#228b22"># 编译阶段 命名为 builder&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">FROM&lt;/span>&lt;span style="color:#cd5555"> golang:1.10.3 as builder&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>&lt;span style="color:#228b22"># ... 省略&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>&lt;span style="color:#228b22"># 运行阶段&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">FROM&lt;/span>&lt;span style="color:#cd5555"> scratch&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>&lt;span style="color:#228b22"># 从编译阶段的中拷贝编译结果到当前镜像中&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">COPY&lt;/span> --from=builder /build/server /&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>docker build&lt;/strong> 根据Dockerfile构建镜像命令&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">docker build [选项] URL|PATH
-f 要用哪一个Dockerfile（指定Path）
-t 给镜像取名字，可加tag（name:tag）
e.g:
docker build -f Dockerfile -t name:tag . 将当前的文件夹作为环境构造镜像
可以以PATH指定的目录作为上下文环境来构建镜像，最好是以空目录为上下文环境，里面只放Dockerfile（除非是放生成镜像必须的文件，因为上下文过大的话发送给daemon会很慢），也可以是指定URL作为构建环境，也就是Git Repository，比如Github
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;strong>FROM&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="color:#8b008b;font-weight:bold">FROM&lt;/span>&lt;span style="color:#cd5555"> image&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>Dockerfile都要以FROM开始，构建一个基本镜像&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>e.g:&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">FROM&lt;/span>&lt;span style="color:#cd5555"> scratch&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>这是Docker Hub上大多数镜像的选择，构建一个默认镜像&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;strong>RUN&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="color:#8b008b;font-weight:bold">RUN&lt;/span> shell_command&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>build镜像时所要执行的命令&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>一般以执行shell命令的格式最佳,默认是以RUN /bin/sh -c command形式执行的&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>一行写不下时可以通过&lt;span style="color:#cd5555">\换&lt;/span>行,执行多个命令最好用&amp;amp;&amp;amp;来相连，这样可以少些一些RUN，因为RUN、ADD、COPY这些命令写一个命令就会加一层，这样会使容器不那么臃肿庞大&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>CMD&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="color:#8b008b;font-weight:bold">CMD&lt;/span> [&lt;span style="color:#cd5555">&amp;#34;executable&amp;#34;&lt;/span>,&lt;span style="color:#cd5555">&amp;#34;param1&amp;#34;&lt;/span>,&lt;span style="color:#cd5555">&amp;#34;param2&amp;#34;&lt;/span>]一般以这种格式最佳（注意都要双引号，因为是JSON格式）&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">CMD&lt;/span>是容器运行时所要执行的命令，旨在指定run容器时所要做的默认动作，跟docker run后跟一个command原理是一样的&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>特别说明：Dockerfile中只能有一个CMD,如果有多个CMD，只有最后一个生效&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>ENTRYPOINT&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>使用方法与CMD相同，但是docker run后面如果跟command会把CMD要执行的命令覆盖掉，ENTRYPOINT要执行的命令不会，甚至能给ENTRYPOINT追加参数
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>LABEL&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="color:#8b008b;font-weight:bold">LABEL&lt;/span> &lt;span style="color:#00688b">key&lt;/span>=&lt;span style="color:#cd5555">&amp;#34;value&amp;#34;&lt;/span> &lt;span style="color:#00688b">key&lt;/span>=&lt;span style="color:#cd5555">&amp;#34;value&amp;#34;&lt;/span> ... &lt;span style="color:#00688b">key&lt;/span>=&lt;span style="color:#cd5555">&amp;#34;value&amp;#34;&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>给镜像加元数据，以键值对的形式多组追加，可以通过&lt;span style="color:#cd5555">\换&lt;/span>行,比如在LABEL里加上maintainer（维护者）等信息&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>可以通过docker inspect来查看&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>EXPOSE&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-dockerfile" data-lang="dockerfile">让运行时的容器在指定端口进行监听，也就是暴露端口,默认是tcp，可以指定udp，如EXPOSE 53/udp&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>可以通过docker run中的-p来覆盖，也可以通过-P将host os上的随机端口与暴露的端口进行绑定&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;strong>ENV&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-dockerfile" data-lang="dockerfile">为运行的容器设置环境变量&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">ENV&lt;/span> key value 一个ENV设置一个环境变量&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>ADD&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="color:#8b008b;font-weight:bold">ADD&lt;/span> &amp;lt;src&amp;gt;...&amp;lt;dest&amp;gt;&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>将src的文件，文件夹拷贝到dest，src可以是一个remote URL，dest可以是相对路径也可以是绝对路径，如果是相对路径那就是拷贝到WORKDIR/相对路径下&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>特别说明：dest如果是文件夹，想把文件拷贝到dest文件夹下，必须在最后加/&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">COPY&lt;/span>指令与ADD用法相同，但是ADD可以从远程url上拷贝，COPY只能拷贝本地宿主机上的文件&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>WORKDIR&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>设置进入容器时的工作目录，能使用ENV设置的环境变量
&lt;/code>&lt;/pre>&lt;h2 id="容器网络配置">容器网络配置&lt;/h2>
&lt;blockquote>
&lt;p>docker network&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">connect 将一个容器部署进某个配置的网络当中，通过ls查看网络名
ls 列出所有网络
inspect 查看网络描述信息
create 创建网络，可通过-d指定方式，有bridge，host等等，可通过--subnet指定子网和后缀
...
要让容器使用docker network创建的网络，在docker run时指定--net即可
&lt;/code>&lt;/pre>&lt;/div>- https://jessestutler.github.io/posts/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ - 本站遵循 CC-BY-NC 4.0 协议</description></item></channel></rss>