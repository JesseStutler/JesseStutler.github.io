<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jesse's Blog</title><link>https://jessestutler.github.io/</link><description>Recent content on Jesse's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Thu, 10 Jun 2021 14:51:48 +0800</lastBuildDate><atom:link href="https://jessestutler.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>K8s Iptables分析</title><link>https://jessestutler.github.io/posts/k8s-iptables%E5%88%86%E6%9E%90/</link><pubDate>Thu, 10 Jun 2021 14:51:48 +0800</pubDate><guid>https://jessestutler.github.io/posts/k8s-iptables%E5%88%86%E6%9E%90/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/k8s-iptables%E5%88%86%E6%9E%90/ -&lt;h1 id="k8s-iptables分析">K8s iptables分析&lt;/h1>
&lt;p>笔者最近因为需要看了下k8s的kube-proxy在默认iptables模式下对于iptables规则是如何管理的，以此作为记录并分享，后面会继续跟进kube-proxy并进行源码分析&lt;/p>
&lt;p>这里笔者分享一套还不错的iptables学习路线：&lt;/p>
&lt;p>&lt;a href="https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables">https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables&lt;/a>&lt;/p>
&lt;h2 id="iptables知识">iptables知识&lt;/h2>
&lt;h3 id="查">查&lt;/h3>
&lt;p>-t [表名] 指定想查看的表的规则，默认为filter表&lt;/p>
&lt;p>-L [链名] 指定想查看的某个表在某个链当中的规则，不写链列出表在所有链当中的规则&lt;/p>
&lt;p>-v 列出详细规则&lt;/p>
&lt;p>-n 不做域名解析，直接显示ip（通常-nvL同行）&lt;/p>
&lt;p>&amp;ndash;line-number 显示行数&lt;/p>
&lt;p>e.g:&lt;/p>
&lt;p>&lt;code>iptables -t nat -L INPUT&lt;/code>&lt;/p>
&lt;p>列出nat表在INPUT链中的所有规则&lt;/p>
&lt;h3 id="增">增&lt;/h3>
&lt;p>-I [链名] 插入规则到指定的链当中（&lt;strong>在链的首部插入&lt;/strong>）&lt;/p>
&lt;p>-I [链名] [序号] 插入规则到指定的链当中（&lt;strong>指定是链的第几条规则&lt;/strong>）&lt;/p>
&lt;p>-A [链名] 插入规则到指定的链当中（&lt;strong>在链的尾部插入&lt;/strong>）&lt;/p>
&lt;p>-s [源地址,[源地址]&amp;hellip;] 或[源地址网段]&lt;/p>
&lt;p>-d [目标地址]&lt;/p>
&lt;blockquote>
&lt;p>用&lt;code>!&lt;/code>在-s或-d前表示取反，非地址匹配&lt;/p>
&lt;/blockquote>
&lt;p>&amp;ndash;sport 源端口&lt;/p>
&lt;p>&amp;ndash;dport 目标端口&lt;/p>
&lt;p>&amp;ndash;sport/dport [起始端口:结束端口] 表示匹配此范围内端口&lt;/p>
&lt;blockquote>
&lt;p>指定源端口和目标端口为扩展匹配条件，-m用来指定扩展模块，如-m tcp -dport 22表示匹配ssh，若不指定-m（最好指定），默认与-p指定的协议相同&lt;/p>
&lt;/blockquote>
&lt;p>-m [模块] 使用模块扩展匹配条件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>离散端口：
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-m multiport --dports 22,53,80
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>需要指定multiport模块用来离散匹配
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>范围ip：
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-m iprange --src-range 192.168.0.211-192.168.0.220
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>加备注：
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-m comment --comment [...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>-p [协议]&lt;/p>
&lt;p>-i [流入网卡]&lt;/p>
&lt;p>-o [流出网卡]&lt;/p>
&lt;p>-j [target] target可以是动作，如DROP,ACCEPT,REJECT等 ；也可以是自定义链，将系统链和自定义链关联起来进行进一步的匹配&lt;/p>
&lt;p>-N [自定义链名] 创建自定义链，将指定规则放到自定义链中方便管理，防止某条系统链过长比较难找，k8s很多都是自定义链&lt;/p>
&lt;p>&lt;strong>在系统链当中定义规则，并指明-j 自定义链名即可将自定义链引用到系统链上，如果规则匹配，就会到自定义链上进行进一步的匹配，如果不指定-j光定义自定义链是不会产生效果的&lt;/strong>&lt;/p>
&lt;h3 id="删">删&lt;/h3>
&lt;ul>
&lt;li>-D [链名] [序号] 删除链的第几条规则（可用&amp;ndash;line-number先查看链的序号）&lt;/li>
&lt;/ul>
&lt;p>或不指定序号，而是根据规则来匹配&lt;/p>
&lt;p>e.g:&lt;/p>
&lt;p>&lt;code>iptables -D INPUT -s 192.168.0.211 -j ACCEPT&lt;/code>&lt;/p>
&lt;p>删除INPUT中filter表的（不指定-t默认为filter）源地址为192.168.0.211，target为ACCEPT的规则&lt;/p>
&lt;ul>
&lt;li>-F [链名] 删除某条链的所有规则&lt;/li>
&lt;/ul>
&lt;p>e.g:&lt;/p>
&lt;p>&lt;code>iptables -t 表名 -F 链名&lt;/code>&lt;/p>
&lt;p>删除指定表中某条链中的所有规则&lt;/p>
&lt;ul>
&lt;li>-X [自定义链名] 删除自定义需要满足以下规则：&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>自定义链没有被任何默认链引用，即自定义链的引用计数为0。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自定义链中没有任何规则，即自定义链为空。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="改">改&lt;/h3>
&lt;ul>
&lt;li>-P [链名] [target] 修改制定链的默认规则&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>iptables黑名单即链的默认规则为ACCEPT，而定义DROP或REJECT规则，白名单即反过来&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>-R [链名] [序号] 修改链中制定第几条规则（有坑，需要匹配写明所有原匹配规则，所以不如删了原来的规则再加一条）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>-E [原链名] [新链名] 将原自定义链名改为新链名&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="保存规则">保存规则&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>第一种&lt;/p>
&lt;p>&lt;code>service iptables save&lt;/code>&lt;/p>
&lt;p>只要没保存，就可以通过&lt;code>service iptables restart&lt;/code>恢复&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二种&lt;/p>
&lt;p>&lt;code>iptables-save &amp;gt; /etc/sysconfig/iptables&lt;/code>&lt;/p>
&lt;p>&lt;code>iptables-restore &amp;lt; /etc/sysconfig/iptables&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="nat">NAT&lt;/h3>
&lt;p>&lt;a href="https://www.zsythink.net/archives/1764">https://www.zsythink.net/archives/1764&lt;/a>&lt;/p>
&lt;h4 id="snat">SNAT&lt;/h4>
&lt;p>-j SNAT &amp;ndash;to-source [ip] 将源ip进行转换&lt;/p>
&lt;p>一般放在POSTROUTING链当中&lt;/p>
&lt;p>也可以放在INPUT链当中&lt;/p>
&lt;h4 id="dnat">DNAT&lt;/h4>
&lt;p>-j DNAT &amp;ndash;to-destination [ip:port] 将目标ip进行转换&lt;/p>
&lt;p>一般放在PREROUTING链当中&lt;/p>
&lt;p>也可以放在OUTPUT链当中&lt;/p>
&lt;h4 id="masquerade">MASQUERADE&lt;/h4>
&lt;p>类似SNAT，只不过SNAT需要指定转换ip，MASQUERADE可以指定-o流出网卡，根据流出网卡的ip自动配置转换ip，应对转换ip变动的情况&lt;/p>
&lt;h4 id="redirect">REDIRECT&lt;/h4>
&lt;p>-j REDIRECT &amp;ndash;to-ports&lt;/p>
&lt;p>端口重定向&lt;/p>
&lt;p>REDIRECT规则只能定义在PREROUTING链或者OUTPUT链中&lt;/p>
&lt;h2 id="kubernetes-iptables分析">Kubernetes iptables分析&lt;/h2>
&lt;h3 id="iptables解析">Iptables解析&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Cluster-IP实际上就是做了个cluster-ip到对应pod的endpoint的DNAT转换&lt;/p>
&lt;ul>
&lt;li>
&lt;p>非本机访问pod：&lt;/p>
&lt;p>PREROUTING &amp;ndash;&amp;gt; KUBE-SERVICE &amp;ndash;&amp;gt; KUBE-SVC-XXX &amp;ndash;&amp;gt; KUBE-SEP-XXX&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本机访问pod：&lt;/p>
&lt;p>OUTPUT &amp;ndash;&amp;gt; KUBE-SERVICE &amp;ndash;&amp;gt; KUBE-SVC-XXX &amp;ndash;&amp;gt; KUBE-SEP-XXX&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>到具体某个pod的查看链过程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>iptables -t nat -nvL OUPUT（或者PREROUTING)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>iptables -t nat -nvL KUBE-SERVICES
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">#SVC规则全在KUBE-SERVICES链当中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">#以Load Balancer服务为例，含三条iptables链：KUBE-MARK-MASQ,KUBE-SVC-P24HJGZOUZD6OJJ7(svc hash值),KUBE-FW-P24HJGZOUZD6OJJ7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">#查看cluster-ip链规则，-d指定了cluster-ip，其中定义了各pod链，命中率按概率算&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>iptables -t nat -nvL KUBE-SVC-P24HJGZOUZD6OJJ7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">#查看具体某个pod链规则，其中包含DNAT转换，转换到具体某个endpoint&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>iptables -t nat -nvL KUBE-SEP-L4YOSO3ZOS4HVO5N
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> DNAT tcp -- * * 0.0.0.0/0 0.0.0.0/0 /* default/echo-load-balance: */ tcp to:10.244.2.162:8080
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>出node的查看链过程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>iptables -t nat -nvL KUBE-MARK-MASQ
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">#上面提到的KUBE-MARK-MASQ链，是在OUTPUT过程中给出node的流量打上标签的，用于在后面POSTROUTING做SNAT转换&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>iptables -t nat -nvL POSTROUTING
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>iptables -t nat -nvL KUBE-POSTROUTING
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">#KUBE-POSTROUTING中规则如下：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Chain KUBE-POSTROUTING (&lt;span style="color:#b452cd">1&lt;/span> references)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pkts bytes target prot opt in out &lt;span style="color:#658b00">source&lt;/span> destination
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b452cd">17&lt;/span> &lt;span style="color:#b452cd">1020&lt;/span> MASQUERADE all -- * * 0.0.0.0/0 0.0.0.0/0 /* kubernetes service traffic requiring SNAT */ mark match 0x4000/0x4000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">#表示匹配打上了0x4000标签的流量，即KUBE-MARK-MASQ中打上的，做SNAT动态转换，将pod ip转换成node ip发往其他node&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>DNAT和SNAT转换过程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">#比如在一台ip为10.0.0.40的机子上，访问cluster ip为10.111.107.12,其中一个pod的endpoint为10.244.2.162:8080，10.244.0.0为flannel.1的ip（因为由flannel.1发出）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10.0.0.40:xxx ——&amp;gt; 10.111.107.12
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | DNAT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> V
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10.0.0.40:xxx ——&amp;gt; 10.244.2.162:8080
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | SNAT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> V
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10.244.0.0:xxx ——&amp;gt; 10.244.2.162:8080
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>NodePort&lt;/p>
&lt;ul>
&lt;li>
&lt;p>非本机访问：&lt;/p>
&lt;p>PREROUTING &amp;ndash;&amp;gt; KUBE-SERVICE &amp;ndash;&amp;gt; KUBE-NODEPORTS &amp;ndash;&amp;gt; KUBE-SVC-XXX &amp;ndash;&amp;gt; KUBE-SEP-XXX&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本机访问：&lt;/p>
&lt;p>OUTPUT &amp;ndash;&amp;gt; KUBE-SERVICE &amp;ndash;&amp;gt; KUBE-NODEPORTS &amp;ndash;&amp;gt; KUBE-SVC-XXX &amp;ndash;&amp;gt; KUBE-SEP-XXX&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>NodePort在KUBE-SERVICES链中最后一条规则，如果&amp;ndash;dst-type为LOCAL，即node ip，则匹配&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-s" data-lang="s">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b452cd">126&lt;/span>K &lt;span style="color:#b452cd">16&lt;/span>M KUBE-NODEPORTS all -- * * &lt;span style="color:#b452cd">0.0.0.0&lt;/span>/&lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0.0.0.0&lt;/span>/&lt;span style="color:#b452cd">0&lt;/span> /* kubernetes service nodeports; NOTE: this must be the last rule in this chain */ ADDRTYPE match dst-type LOCAL
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看KUBE-NODEPORTS链：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>iptables -t nat -nvL KUBE-NODEPORTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">#第一条用来打标签，第二条用来转到cluster-ip链规则来做DNAT转换&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> KUBE-MARK-MASQ tcp -- * * 0.0.0.0/0 0.0.0.0/0 /* default/echo-load-balance: */ tcp dpt:32591
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> KUBE-SVC-P24HJGZOUZD6OJJ7 tcp -- * * 0.0.0.0/0 0.0.0.0/0 /* default/echo-load-balance: */ tcp dpt:32591
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>DNAT和SNAT转换过程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">#比如在一台ip为10.0.0.40的机子上，访问NodePort,端口为32591,其中一个pod的endpoint为10.244.2.162:8080，10.244.0.0为flannel.1的ip（因为由flannel.1发出）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10.0.0.40:xxx ——&amp;gt; 10.0.0.40:32591
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | DNAT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> V
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10.0.0.40:xxx ——&amp;gt; 10.244.2.162:8080
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | SNAT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> V
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10.244.0.0:xxx ——&amp;gt; 10.244.2.162:8080
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://res.cloudinary.com/stackrox/v1578619751/kube-networking-5_zswvwp.svg" alt="img">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Load Balancer：&lt;/p>
&lt;p>Load Balancer会有KUBE-FW-XXX链在KUBE-SERVICES链中定义，用来匹配Load Balancer external ip，如果命中，会有三条规则，第二条导向Cluster-IP：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> KUBE-MARK-MASQ all -- * * 0.0.0.0/0 0.0.0.0/0 /* default/echo-load-balance: loadbalancer IP */
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> KUBE-SVC-P24HJGZOUZD6OJJ7 all -- * * 0.0.0.0/0 0.0.0.0/0 /* default/echo-load-balance: loadbalancer IP */
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> KUBE-MARK-DROP all -- * * 0.0.0.0/0 0.0.0.0/0 /* default/echo-load-balance: loadbalancer IP */
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KUBE-MARK-DROP也和KUBE-MARK-MASQ一样，是用来打标签的，用来应对服务可能没endpoint的情况，打完标签后进入INPUT链或者OUTPUT链的规则当中，匹配KUBE-FIREWALL链，将打上了标签的流量DROP掉&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="参考">参考&lt;/h3>
&lt;p>&lt;a href="https://juejin.cn/post/6844904098605563912">https://juejin.cn/post/6844904098605563912&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://yuerblog.cc/2019/12/09/k8s-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%88%86%E6%9E%90service%E7%94%9F%E6%88%90%E7%9A%84iptables%E8%A7%84%E5%88%99/">https://yuerblog.cc/2019/12/09/k8s-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%88%86%E6%9E%90service%E7%94%9F%E6%88%90%E7%9A%84iptables%E8%A7%84%E5%88%99/&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2017/03/27/Kubernetes-kube-proxy.html">https://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2017/03/27/Kubernetes-kube-proxy.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.stackrox.com/post/2020/01/kubernetes-networking-demystified/">https://www.stackrox.com/post/2020/01/kubernetes-networking-demystified/&lt;/a>&lt;/p>
- https://jessestutler.github.io/posts/k8s-iptables%E5%88%86%E6%9E%90/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>NSDI17 ExCamera</title><link>https://jessestutler.github.io/posts/nsdi17-excamera/</link><pubDate>Tue, 18 May 2021 14:45:44 +0800</pubDate><guid>https://jessestutler.github.io/posts/nsdi17-excamera/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/nsdi17-excamera/ -&lt;h1 id="nsdi17-excamera">NSDI17-ExCamera&lt;/h1>
&lt;p>这是一篇将video encoding改造到serverless平台上的文章&lt;/p>
&lt;p>论文链接：https://www.usenix.org/conference/nsdi17/technical-sessions/presentation/fouladi&lt;/p>
&lt;h2 id="mu框架">mu框架&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;h3 id="大致流程">大致流程&lt;/h3>
&lt;p>AWS s3 invoke第一个Worker（function实例），然后Worker与Coordinator建立TLS连接并保持（Coordinator通过RPC call来调控Worker的状态，Worker就是一个有限状态机），当Coordinator收到来自Worker的message时，就会根据状态转换逻辑产生新的状态给Worker并发送下一个RPC请求。&lt;/p>
&lt;p>Coorinator是dependency-aware的，他会根据Worker产生的output来指派可以处理这个output的worker，这样就可以顺序执行而不会产生死锁&lt;/p>
&lt;h2 id="出现原因">出现原因&lt;/h2>
&lt;p>传统的视频encoding速度太慢，一些实时的视频处理平台需要快速的视频上传业务&lt;/p>
&lt;blockquote>
&lt;p>背景知识：我们都知道视频由一帧帧的图片组成，对于将一段视频压缩成比特流来说，有些帧与帧之间，图片的某些部分是重复的，那压缩成比特流就不必重复，encoding过程就是花费cpu时间来寻找帧与帧之间的联系，从而尽可能的压缩输出的比特流大小；但是这样带来的问题就是帧与帧之间会存在依赖关系，从而不能将比特流从中间段进行解码，比如说直播的时候有不同的清晰度，想要切换成更高清的流。现在引入Stream Access Point来切分视频数据流&lt;/p>
&lt;/blockquote>
&lt;p>借助Stream Access Point技术（将视频数据流进行切分，各段数据流都是独立的，段与段之间的帧没有依赖关系，VP8/VP9使用的是
&amp;ldquo;key frame&amp;quot;概念），&lt;strong>可以将各段encoding过程改造成使用相同的function来处理&lt;/strong>，各段压缩完成之后再进行简单的连接（串行），形成一个完整的视频数据流&lt;/p>
&lt;h2 id="excamera-encoding流程">ExCamera encoding流程&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>（并行）使用&lt;em>vpxenc&lt;/em>（谷歌优化的encoder）encode六个帧，都以key frame为开头（也就是使用Stream Access Point分割视频数据流）,这代表一个chunk&lt;/p>
&lt;/li>
&lt;li>
&lt;p>（并行）使用ExCamera设计的encoder将原先&lt;em>vpxenc&lt;/em>生成的key frame替换成与前面部分的encoder产生的输出相关联的inter frame（因为key frame会影响压缩速率，所以ExCamera针对此进行了优化）。最后生成的chunk只有一个key frame为开头。&lt;/p>
&lt;blockquote>
&lt;p>这step2与step3之间还涉及到很多并行优化步骤，因为涉及到视频encode和decode背景，略过&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>（串行）将各个chunk顺序连接起来&lt;/p>
&lt;/li>
&lt;/ol>
- https://jessestutler.github.io/posts/nsdi17-excamera/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>ATC20——Faasm</title><link>https://jessestutler.github.io/posts/atc20faasm/</link><pubDate>Tue, 18 May 2021 14:43:26 +0800</pubDate><guid>https://jessestutler.github.io/posts/atc20faasm/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/atc20faasm/ -&lt;h1 id="atc20faasm">ATC20——Faasm&lt;/h1>
&lt;p>这是一篇关于webassembly sandbox的文章&lt;/p>
&lt;p>论文链接：https://www.usenix.org/conference/atc20/presentation/shillaker&lt;/p>
&lt;h2 id="为什么要提出wasm-sandbox本文是faaslet">为什么要提出WASM-sandbox（本文是Faaslet)？&lt;/h2>
&lt;p>大多数serverless平台使用的是容器承载function，但是对于容器来说，启动开销和过多的memory footprint仍然与serverless场景不太匹配（像边缘场景如果容器是overprovision的，性能会随着资源可用量的减少而下降；而且边缘如果是多租户的，long-running container也不合需求，如果资源不够用了需要频繁的驱逐），而且现有以容器为承载的方案（尽管有提出本地存储来减少访问数据开销的）会产生&lt;strong>冗余数据&lt;/strong>，每个函数都有一份拷贝，而且需要重复的序列化和网络开销。对比docker来说，faaslet能够极大的减少冷启动延迟，减少开销，让一台机器承载更多的sandbox&lt;/p>
&lt;h2 id="fasslet">Fasslet&lt;/h2>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqdjwbsburj30p009umyy.jpg" alt="截屏2021-05-10 下午7.21.46">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>function和其library，runtime都会编译为WASM；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cgroup做cpu周期隔离；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>network namespace做Network隔离和提供virtual network interface；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>faaslet以线程运行，共享进程资源；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>部分WASI+部分POSIX实现（图中Host interface）做system calls，因为WASI是基于compability-based security的，所以对于资源的访问是通过不可伪造的句柄来保存引用的&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>两层状态共享机制&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;p>local状态共享就是多个faaslet（多个线程）共享父进程的同一块内存区域，global负责集群内状态的同步&lt;/p>
&lt;ul>
&lt;li>faaslet快照&lt;/li>
&lt;/ul>
&lt;p>预初始化faaslet并做成快照，可以减少冷启动时间和各种开销&lt;/p>
- https://jessestutler.github.io/posts/atc20faasm/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>ATC18——容器优化方案SOCK</title><link>https://jessestutler.github.io/posts/atc18%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88sock/</link><pubDate>Tue, 18 May 2021 14:41:22 +0800</pubDate><guid>https://jessestutler.github.io/posts/atc18%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88sock/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/atc18%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88sock/ -&lt;h1 id="atc18容器优化方案sock">ATC18——容器优化方案SOCK&lt;/h1>
&lt;p>这是一篇优化容器冷启动的文章&lt;/p>
&lt;p>论文链接：https://www.usenix.org/conference/atc18/presentation/oakes&lt;/p>
&lt;h2 id="解构containerdocker瓶颈">解构container（docker瓶颈）&lt;/h2>
&lt;ul>
&lt;li>Bind mount可能比AUFS（或overlay）性能更好&lt;/li>
&lt;li>频繁的container创建和删除（涉及到频繁的namespace的创建和删除，可能会有性能瓶颈，比如network namespace，并发的creation和cleanup越多延迟越高），是不是可以把一些不必要的namespace隔离给剔除或者进行一些优化（disable创建或删除时不必要的影响性能的功能）&lt;/li>
&lt;li>频繁的创建和删除cgroup不如reuse cgroup，比如维护一个初始化好的cgroup池&lt;/li>
&lt;li>当host上挂载的越多，mount namespace拷贝的速度就越慢，简单的做法可以考虑使用chroot&lt;/li>
&lt;/ul>
&lt;h2 id="sock优化方案">SOCK优化方案&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Lean containers:&lt;/p>
&lt;ul>
&lt;li>用bind mount代替overlay，分四层：系统层（base），package层（read-only，用来package caching），code层（lambda代码），scratch层（就是container layer，可写层）&lt;/li>
&lt;li>用cgroup pool来分配在container创建时分配cgroup，container删除时重新回到池中&lt;/li>
&lt;li>将mount namespace和network namespace省去，其瓶颈在docker瓶颈中已提到&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Zygote机制：&lt;/p>
&lt;p>Zygote container就是一些已经预import需要的package的容器，内含Zygote进程，这样从这个进程fork出的新进程（子进程）并创建出的新容器不需要做重复性的初始化工作，直接从内存读相同的内容就好了，也就是：&lt;/p>
&lt;p>&lt;strong>含Zygote进程的container&amp;ndash;&amp;gt;含从Zygote fork出的子进程的container&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>三级缓存：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>handler cache：&lt;/p>
&lt;p>将idle instance pause，不消耗cpu但是消耗内存，之后再有request过来unpause是比新创建一个container快的（warm start）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>install cache：&lt;/p>
&lt;p>lean containers中的package层，read-only且被所有container共享&lt;/p>
&lt;/li>
&lt;li>
&lt;p>import cache:&lt;/p>
&lt;p>就是Zygote机制，但是命中和驱逐机制需要定制。命中可能与传统cache不同，存在多命中的情况（handler需要的包可能既在tree cache中的子节点也可能是父节点），这时需要找到最合适的entry（也就是Zygote进程）；驱逐因为Zygote进程会都有相同的包而存在共享内存的情况所以比较复杂&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
- https://jessestutler.github.io/posts/atc18%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88sock/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>ATC18——窥探Serverless平台</title><link>https://jessestutler.github.io/posts/atc18%E7%AA%A5%E6%8E%A2serverless%E5%B9%B3%E5%8F%B0/</link><pubDate>Tue, 18 May 2021 14:31:18 +0800</pubDate><guid>https://jessestutler.github.io/posts/atc18%E7%AA%A5%E6%8E%A2serverless%E5%B9%B3%E5%8F%B0/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/atc18%E7%AA%A5%E6%8E%A2serverless%E5%B9%B3%E5%8F%B0/ -&lt;h1 id="atc18窥探serverless平台">ATC18——窥探serverless平台&lt;/h1>
&lt;p>这是一篇利用逆向工程测试Serverless平台的文章&lt;/p>
&lt;p>论文链接：https://www.usenix.org/conference/atc18/presentation/wang-liang&lt;/p>
&lt;h2 id="qa">QA&lt;/h2>
&lt;p>Q:隔离的减少会导致I/O，networking，coldstart等表现的下降？&lt;/p>
&lt;p>A:是的。如果VM中有多个instance实例会造成资源争夺的现象（见衡量指标中的I/O &amp;amp; network throughput）&lt;/p>
&lt;p>Q:同一VM是运行多个function instance吗？&lt;/p>
&lt;p>A：是。AWS可以通过I/O测试发现多个function instance共享/proc中的文件&lt;/p>
&lt;p>Q:不同租户的function实例可以放到同一VM里吗？&lt;/p>
&lt;p>A：可以但并没有平台采用（安全隔离性会有问题:side channel attack）&lt;/p>
&lt;p>Q:idle instance（暂无请求的实例，但是不会收用户费用）是要退出并收回资源还是再利用（先放到池里）处理后续的请求？&lt;/p>
&lt;p>&lt;a href="https://aws.amazon.com/cn/blogs/compute/container-reuse-in-lambda/">https://aws.amazon.com/cn/blogs/compute/container-reuse-in-lambda/&lt;/a>&lt;/p>
&lt;p>A:这个问题值得考量。一方面，idle instance会一直占用VM的资源；而另一方面，如果有突发的请求又可以减少instance的冷启动时间。所以折中来说，AWS采用的是将一个函数的一半的instance每300s停掉并回收资源，剩下的instance运行直到一个最大idle time为止。&lt;/p>
&lt;p>Q:多个request会被同个instance接收吗？&lt;/p>
&lt;p>A：会。Google针对负载过多的话会开新实例&lt;/p>
&lt;p>Q:function update是开新实例吗，还是在旧实例的基础上改？&lt;/p>
&lt;p>A：开新实例，负载会从旧实例慢慢过渡到新实例，但是有一个时间差&lt;/p>
&lt;h2 id="衡量指标">衡量指标&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Cold-start latency（&amp;amp; warm start latency）&lt;/p>
&lt;p>这里代表的是function的冷启动时间（AWS使用了VM池在function启动之前就准备接收function的调度，这样基本上只受scheduling latency的影响）&lt;/p>
&lt;p>warm start指function在执行完之后，暂时“冻住”，为不久后再有请求而“解冻”并处理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Function instance lifetime&lt;/p>
&lt;p>即使instance仍然在运行，但是到达一个lifetime也会被terminated，租户如果想用一个function维护in-memory state的话肯定想让这个instance运行地更久一点&lt;/p>
&lt;p>AWS instance lifetime中位数为6.2小时&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Maximum idle time before shut down&lt;/p>
&lt;/li>
&lt;li>
&lt;p>I/O &amp;amp; network throughput&lt;/p>
&lt;p>当VM中的function实例越多，每个function的I/O和network吞吐量会越小，而且会受到function分配到的内存的影响，function占用的内存越大，吞吐量越高。所以，存在一个&lt;strong>VM多instance的资源争用问题&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CPU usage（AWS是根据code的预配置memory量来分配cpu周期，memory量越多CPU周期越多，这样冷启动的时间也会减少越多，而且公平）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Memory usage&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="可以利用点">可以利用点&lt;/h2>
&lt;h3 id="优化调度">优化调度&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>AWS尝试将function调度视为一个装箱问题(bin-packing problem)，尽可能的将新生成的function实例装入已有的VM实例当中，以提高==内存利用率==。&lt;strong>调度与function code无关&lt;/strong>。但是，这也会引入&lt;strong>instance的资源争用问题&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果function update的话可能会造成新一轮请求仍然被旧实例（可能是旧的函数的新实例，也可能是未被shut down的旧函数的旧实例）处理，怎么优化调度器？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>既然冷启动时间用VM就绪池的方法可以减少VM启动的这一部分latency，如何再减少scheduling latency？&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="优化冷启动时间">优化冷启动时间&lt;/h3>
&lt;ul>
&lt;li>减少scheduling latency&lt;/li>
&lt;li>使用library caching减少函数库的加载时间，只加载需要的库（Unikernel）&lt;/li>
&lt;/ul>
&lt;h3 id="优化隔离性">优化隔离性&lt;/h3>
&lt;ul>
&lt;li>更多的创造instance新实例而不是使用旧实例（符合serverless理念）&lt;/li>
&lt;li>Short-lived instance&lt;/li>
&lt;li>small memory-footprint functons&lt;/li>
&lt;/ul>
- https://jessestutler.github.io/posts/atc18%E7%AA%A5%E6%8E%A2serverless%E5%B9%B3%E5%8F%B0/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>ATC18——高性能workflowSAND</title><link>https://jessestutler.github.io/posts/atc18%E9%AB%98%E6%80%A7%E8%83%BDworkflowsand/</link><pubDate>Tue, 18 May 2021 14:28:02 +0800</pubDate><guid>https://jessestutler.github.io/posts/atc18%E9%AB%98%E6%80%A7%E8%83%BDworkflowsand/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/atc18%E9%AB%98%E6%80%A7%E8%83%BDworkflowsand/ -&lt;h1 id="atc18高性能workflow-sand">ATC18——高性能workflow SAND&lt;/h1>
&lt;p>这是一篇关于优化serverless workflow的文章&lt;/p>
&lt;p>论文下载链接：https://www.usenix.org/conference/atc18/presentation/akkus&lt;/p>
&lt;h2 id="sandbox">Sandbox&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>同属于同一个workflow的function属于一个&lt;strong>application&lt;/strong>，&lt;strong>一个application一个container&lt;/strong>，而不是一个function一个container&lt;/p>
&lt;blockquote>
&lt;p>但是有可能会引入资源竞争问题？&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>当有request到来时，==通过fork function实例来快速水平扩展==（&lt;strong>实验证明，fork是最快的，比直接执行二进制文件创建进程都要快&lt;/strong>），而不是频繁的冷启动一个不同的container。而且，同一个function的不同实例（也就是进程）可以共享内存，库只要加载一次就够了，相比另起一个container的内存占用量，内存占用量少很多。function执行完之后可以回收资源，等有请求来了再fork新实例，相比为了解决负载尖峰而一直保持container idle占用资源，可以避免资源一直被占用。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="message-bus">Message Bus&lt;/h2>
&lt;p>&lt;strong>SAND使用了一个机制：同一台host中的function通过local message bus来沟通，不同host中的function通过global message bus来沟通，而且global message bus可以保存local message bus中的消息作为备份（用来容错）&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>tips：local/global message bus都为不同的funciton维护有不同的队列（或者topic），global像kafka这种实现有partition做容错，host agent订阅global message bus，本地function订阅local message bus。而且message bus不直接传递data，而是传递数据的引用（比如local可以通过in-memory的key-value存储，来快速获取数据，global可以通过分布式存储来获取数据），不仅存取数据快，这样检查状态和回滚也方便。&lt;/p>
&lt;/blockquote>
&lt;p>鉴于现有的serverless平台中的workflow沟通机制，即使两个function在同一台机子当中，也是要通过外部消息队列服务来存取的，这引入了极大的延迟，local message bus能够削减这段延迟时间&lt;/p>
&lt;h2 id="host-agent">Host Agent&lt;/h2>
&lt;p>Host agent是每台机子上的代理，他负责local message bus和global message bus的合作（比如备份，细节里会细说）；为自己机子上的函数从global message bus存取消息（订阅topic）；孵化容器和fork function&lt;/p>
&lt;h2 id="细节">细节&lt;/h2>
&lt;h3 id="如何做备份">如何做备份&lt;/h3>
&lt;p>当function产生message到local message bus当中自己的队列时，会产生&lt;strong>一份拷贝给host agent的队列&lt;/strong>，然后host agent将这份拷贝消息放到global message bus的这个function的队列（或者topic）当中，==作为备份并且打上标签表示完成状态==，host agent会追踪要接收这个消息的下一个function的完成进度，顺利完成会将状态转为finished，处理失败会将状态转为failed并交给另一个机子上的function处理&lt;/p>
&lt;h3 id="workflow流程">workflow流程&lt;/h3>
&lt;p>假设有两个function完成workflow，一台机子（两个partiton)&lt;/p>
&lt;p>Step1：user request发送给function1，global message bus将消息放到partition1&lt;/p>
&lt;p>Step2: host agent（host agent负责global的订阅）将消息从partition1取出并放到local message bus的function1的队列&lt;/p>
&lt;p>Step3.1: function1（function负责local的订阅）将消息从local的自己队列中取出，fork新实例并处理，然后产生下一个消息给funtion2，将消息放到local message bus的function2队列&lt;/p>
&lt;p>Step3.2：同时，会有一份3.1中产生的消息的==拷贝==放到local message bus的host agent的队列，host agent将这个消息放到global的partition2中作为==备份==，并打上标签表示状态‘processing'&lt;/p>
&lt;p>Step4.1: function2从local自己队列中取出消息并处理，因为他是workflow的最后一步，所以完成后直接产生新消息给local中的host agent队列，host agent将这个消息放到global中&lt;/p>
&lt;p>Step4.2：host agent追踪到funciton2顺利完成，将标签3.2中的消息改为finished表示完成&lt;/p>
&lt;p>Step5：回复user表示完成&lt;/p>
- https://jessestutler.github.io/posts/atc18%E9%AB%98%E6%80%A7%E8%83%BDworkflowsand/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Serverless分析</title><link>https://jessestutler.github.io/posts/serverless%E5%88%86%E6%9E%90/</link><pubDate>Tue, 18 May 2021 14:13:36 +0800</pubDate><guid>https://jessestutler.github.io/posts/serverless%E5%88%86%E6%9E%90/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/serverless%E5%88%86%E6%9E%90/ -&lt;h1 id="serverless分析">Serverless分析&lt;/h1>
&lt;p>本文根据Berkeley rise lab的综述Cloud Programming Simplifified:&lt;/p>
&lt;p>A Berkeley View on Serverless Computing并结合其他相关材料进行总结，探究serverless的研究点，本文会持续进行更新。&lt;/p>
&lt;p>&lt;em>简单的说，Serverless就是FaaS+BaaS&lt;/em>&lt;/p>
&lt;h3 id="特点">特点&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>按使用量付费（无请求时无资源无分配无花费，有请求时按使用量，按时间计算付费），性能提高（高并发量），autoscale，强隔离性（多租户），可供有突发流量情况而又无服务器扩展需求的公司使用；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>低请求量服务改造&lt;/strong>：原先需要一直监听请求的应用，当无请求来时需要一直占用资源，而改造成serverless可以用function代替原先的应用，这样无请求来临时可以down to zero，有请求来时再invoke一个或多个function实例（而且这些function是可以并行的）并进行处理；（不仅是针对可以减少资源使用量，而且可以应对流量尖峰）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由外部服务触发比如S3（有object更新，比如新增图片），消息队列（事件驱动，收到事件），或者以API gateway的形式（可以是以Backend或以function的形式）等待HTTP request到来触发&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>一定是&lt;/strong>stateless，无法保证写到memory或者local disk的数据（VM上）下次被invoked还能读到，需要借助外部存储服务来保存状态或数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>适合short-lived task&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>从serverful过渡到serverless就像从汇编语言过渡到高级语言一样，汇编语言计算一个c=a+b需要指定寄存器，存放，计算结果然后并存回，而serverful就像汇编语言一样需要先知道哪些资源是可用的，然后给资源加载code和环境，执行计算，再得到结果，这些原先需要平台使用者去知晓，但是serverless不需要programmer去知晓和管理资源，只需要&lt;strong>编写code，编写function，编写业务就够了&lt;/strong>&lt;/p>
&lt;h2 id="现今serverless的有限性">现今Serverless的有限性&lt;/h2>
&lt;h3 id="存储对于细粒度操作的局限性">存储对于细粒度操作的局限性&lt;/h3>
&lt;p>因为function之间是相互隔离的，&lt;strong>所以需要借助外部存储服务(BaaS)来提供状态的支持&lt;/strong>，这是serverless的特性所致。但是对于划分到function这么细粒度的操作来说，现在的外部存储服务要不是太贵（access或者storage）要不就是延迟太高，e.g:对象存储比如AWS S3等，access花费和延迟过高；key-value数据库存储费用高，扩容慢；内存存储如redis等没有容错性，不能自动扩缩。当然这要看应用的要求，但还是与serverless理想的存储方案相差不少。&lt;/p>
&lt;h3 id="缺少细粒度的消息沟通">缺少细粒度的消息沟通&lt;/h3>
&lt;p>背景：两个task合作，taskA需要taskB的output作为input，但是不知道何时output会过来，所以需要引入消息中间件，但是现有的消息中间件对于细粒度(task/function)操作的延迟和花费太高&lt;/p>
&lt;p>可能的解决方案：自己设计消息通知机制比如长期运行一个汇集消息的server，能够以命名的方式直接定位到function实例从而获取到ouput等&lt;/p>
&lt;h3 id="标准沟通模式对于细粒度的性能太差">标准沟通模式对于细粒度的性能太差&lt;/h3>
&lt;p>背景：broadcast，shuffle，aggregation都是分布式系统中重要的原语，但是如果划分粒度过细，比如拿聚合来说，VM实例中的function如果本地不做聚合而每次聚合都需要到远端聚合，那么这个消息数量会成倍增加，shuffle则更多&lt;/p>
&lt;h3 id="冷启动的局限性">冷启动的局限性&lt;/h3>
&lt;p>1）启动function需要一定时间（分配和加载资源：分配VM，初始化container，将function的静态文件拷贝到container）&lt;/p>
&lt;p>2）需要一些时间去下载函数执行环境（OS，库，语言的runtime比如JVM等）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>函数的package依赖需要经过远端的download，local install，import过程，这个时间比较长，是否可以在本地machine上预先下载好所有语言涉及的包？（通过压缩的方式存储）这样直接去本地加载package，省去去远端下载package的时间。&lt;strong>所有container通过overlayfs或者bind mount共享已经安装好的package&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SOCK：利用Zygote机制预import一些需要的package（这样的Zygote很多，需要预import什么package就fork出新的Zygote），这样从Zygote进程fork出的新子进程不需要进行同样的初始化操作，直接从内存读取即可（减少开辟新内存的消耗）&lt;/p>
&lt;blockquote>
&lt;p>tips：fork出的子进程与父进程共享堆栈，fd，代码段，由于copy-on-write，只有子进程写时才会完全拷贝&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>含Zygote进程的container&amp;ndash;&amp;gt;含从Zygote fork出的子进程的container&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>3）有些应用对于代码需要做一些定制的初始化操作，需要花费一定时间（比如加载和初始化数据结构，库等）&lt;/p>
&lt;p>4）如果需要频繁冷启动，namespace的频繁creation和cleanup需要性能损耗&lt;/p>
&lt;h4 id="什么时候冷启动会发生">什么时候冷启动会发生？&lt;/h4>
&lt;ol>
&lt;li>当function的code或者配置改变的时候，或者function第一次部署的时候&lt;/li>
&lt;li>idle instance被shut down&lt;/li>
&lt;li>instance到了最大age被shut down（即使仍然在运行）&lt;/li>
&lt;li>之前的instance都在忙于处理请求，需要横向扩展的时候&lt;/li>
&lt;/ol>
&lt;h4 id="什么时候需要考虑冷启动的影响">什么时候需要考虑冷启动的影响？&lt;/h4>
&lt;p>也许像要访问存储服务的function本来就需要等待存取的latency，冷启动时间相对这段latency可有可无；也许实时数据流服务会频繁地invoke function，function会一直处理event很多次（可能200000次在到达最大age之前），那冷启动时间也可有可无。&lt;/p>
&lt;p>但是对于请求量较少的function，可能一小时invoke一次，就有可能中间被shut down，需要每次都冷启动，那就需要考虑冷启动的开销，如果冷启动需要加载的依赖和库过大，就有可能需要很多的冷启动时间；对于需要快速回应的应用也需要考虑冷启动的影响&lt;/p>
&lt;h4 id="解决冷启动方案">解决冷启动方案&lt;/h4>
&lt;ol>
&lt;li>AWS使用VM就绪池，在function启动之前就准备接收function的调度，这样基本上只受scheduling latency的影响&lt;/li>
&lt;li>尽可能的减少依赖，尽可能地用加载较快的语言（像Java中的JVM加载较慢）&lt;/li>
&lt;/ol>
&lt;h4 id="降低冷启动时间的好处">降低冷启动时间的好处&lt;/h4>
&lt;ol>
&lt;li>可以让idle instance更少一些，可用资源更多一些（这样就不用因为担心冷启动时间过长而一直等待后续的请求了）&lt;/li>
&lt;/ol>
&lt;h2 id="serverless可以探索的点">Serverless可以探索的点&lt;/h2>
&lt;h3 id="abstraction">Abstraction&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Resouce requirements&lt;/p>
&lt;p>不要让serverless平台的使用者来指定要使用多少资源，这样违背于serverless的理念（不应该管理资源），而且会降低资源的利用率。&lt;strong>更好的做法&lt;/strong>是让cloud provider来推断出需要使用多少资源，比如&lt;strong>静态代码分析，归档之前跑完的数据，动态编译等等&lt;/strong>，总而言之就是要自动的推断出需要多少资源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Data dependencies&lt;/p>
&lt;p>现在的serverless平台无法知晓function之间存在什么数据依赖，甚至需要交换的数据的规模。&lt;strong>更好的做法&lt;/strong>是暴露一个API让应用指明function的computation graph，以便更好地放置function的位置；而且可以引入coordinator来解决function之间顺序依赖的关系，和调控function的状态（function为有限状态机，收到消息发生状态改变）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="system">System&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Storage&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Ephemeral storage&lt;/strong>（暂时存储）&lt;/li>
&lt;/ol>
&lt;p>既然serverless computing需要的是暂时的状态存储，当计算结束时这些状态就可以丢弃，那么可以用暂时存储的方案，比如用内存存储（以分布式内存存储的方式），利用RDMA来减少延迟，利用共享内存的方式来减少serverful computing中内存被VM实例独占，无用内存碎片过多的情况&lt;/p>
&lt;ol start="2">
&lt;li>Durable storage（长期存储）&lt;/li>
&lt;/ol>
&lt;p>大部分都是暂时存储的情况（我觉得serverless也是适用于暂时存储），但是如果针对于设计serverless数据库的话需要长期存储，可能需要多个存储服务的结合，以及像SSD这样提高硬盘的IOPS&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Coordination/signaling service&lt;/p>
&lt;p>&lt;strong>解决缺少细粒度的消息沟通和数据一致性问题&lt;/strong>（因为多个function可能会放到一起，所以分布式系统中的一致性算法和leader election不适用）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Minimize startup time&lt;/p>
&lt;p>&lt;strong>解决冷启动的局限性&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>解决1）：提供更新的轻量级的隔离机制（e.g:Firecracker）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>解决2）：利用unikernels，预配置硬件，静态分配数据结构，只包含应用所需的驱动和函数库等；或者动态地加载函数库（有点类似ddl）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>解决3）：提前做初始化操作；当做完初始化操作call readiness API去通知function工作；利用warm pool存放已经加载好的拥有流行的系统和库的实例等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>WebAssembly&lt;/strong>，有一项调查显示其实50%的function运行时间不超过100ms，但是启动container和加载runtime时间却远远超过100ms以上。&lt;/p>
&lt;blockquote>
&lt;p>VM或者container初始化需要设置system library以供系统调用使用，这会引入开销；且VM或container下的现有付费模型是根据内存使用量和使用时间来计算的，像细粒度的cpu周期使用量等没有涉及到&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="network">Network&lt;/h3>
&lt;p>解决标准沟通模式对于细粒度的性能太差问题，解决方案可同Abstraciton——data dependencies，让应用提供一个computation graph，以便serverless平台能够将一些function放置到同一VM实例中，&lt;strong>减少通过network发送的消息，尽量在本地先处理完&lt;/strong>&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;p>1）eBPF Tail &amp;amp; Function Calls？&lt;/p>
&lt;h3 id="security">Security&lt;/h3>
&lt;p>暂不考虑&lt;/p>
&lt;h3 id="architecture">Architecture&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>硬件的异构性和性能提升陷入瓶颈&lt;/p>
&lt;p>背景：同样的架构但是不同时代的产品，虽然价格一样但是速度可能不同；硬件性能提升陷入瓶颈&lt;/p>
&lt;p>解决方法：&lt;/p>
&lt;p>1）使用语言特定的处理器提升处理速度&lt;/p>
&lt;p>2）使用DSA（Domain Specific Architectures），比如GPU加速图像处理，TPU加速factor处理等&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="serverless已经适配的应用持续更新">Serverless已经适配的应用（持续更新）&lt;/h2>
&lt;h3 id="multimedia-processing">Multimedia processing&lt;/h3>
&lt;ul>
&lt;li>比如有一个图片上传（比如用户上传头像）到AWS S3这样的object storage，触发function将图片处理成缩略图，然后重新存回到AWS S3或者网站自己的存储服务当中&lt;/li>
&lt;li>或者有一个文件上传后触发function将文件进行压缩然后重新存回&lt;/li>
&lt;/ul>
&lt;h3 id="database">Database&lt;/h3>
&lt;ul>
&lt;li>当数据库更新的时候invoke一些function进行一些动作，比如添加或删除的时候&lt;/li>
&lt;li>网站上有天气系统，当点击查看时触发function取得数据库的天气数据&lt;/li>
&lt;li>支撑购物系统快速获取商品信息&lt;/li>
&lt;/ul>
&lt;h3 id="iot-sensor-input-messages">IoT sensor input messages&lt;/h3>
&lt;ul>
&lt;li>处理或过滤来自IoT device的MQTT消息，实时性要求高&lt;/li>
&lt;/ul>
&lt;h3 id="stream-processing-at-scale">Stream processing at scale&lt;/h3>
&lt;ul>
&lt;li>连接消息源处理事件流，实时性要求高，serverless弹性扩缩能力和高并发能力天然适合&lt;/li>
&lt;/ul>
&lt;h3 id="batch-jobs-or-scheduled-tasksworkflow需要给定状态图">Batch jobs or scheduled tasks（workflow，需要给定状态图）&lt;/h3>
&lt;ul>
&lt;li>一天内不会需要很多时间处理的batch job，可以在一天内的其他时间不需要一直running&lt;/li>
&lt;/ul>
&lt;h3 id="http-rest-apis-and-web-applications天然适合">HTTP REST APIs and web applications（天然适合）&lt;/h3>
&lt;ul>
&lt;li>简单的REST操作适合serverless&lt;/li>
&lt;/ul>
&lt;h2 id="serverless可以优化的应用持续更新">Serverless可以优化的应用（持续更新）&lt;/h2>
&lt;p>&lt;strong>优点&lt;/strong>&lt;/p>
&lt;p>1）function实例启动快&lt;/p>
&lt;p>2）花费少（按使用量计费）&lt;/p>
&lt;p>3）可以invoke多个实例并行处理请求（&lt;strong>主要原因&lt;/strong>）&lt;/p>
&lt;p>&lt;strong>引入的问题&lt;/strong>（如何将原来的应用迁移成细粒度的function）&lt;/p>
&lt;p>1）如果仅仅是简单地将应用划分成不同的代码段，一个代码段一个function，那这些不同的function不能很好地用到warm start，每次都是cold start&lt;/p>
&lt;p>2）可能会受到平台实例并发数量的限制&lt;/p>
&lt;p>3）如果function instance是有顺序协作关系的（以链的形式），可能会发生死锁&lt;/p>
&lt;p>4）并发性能是提高了，但是如何保证拥有和改造前应用相近的质量？（是否要斟酌牺牲一点？）&lt;/p>
&lt;h3 id="video-encodingcompute-heavy-task">video encoding(compute-heavy task)&lt;/h3>
&lt;p>背景：现有的编码方案需要花费数十分钟甚至数十小时去上传视频&lt;/p>
&lt;p>已有的解决方案：ExCamera，以函数语义并行执行编码的慢的部分，串行快的部分&lt;/p>
&lt;h3 id="mapreduce">MapReduce&lt;/h3>
&lt;p>背景：Map，Shuffle，Reduce皆可以移植到serverless computing，在mapreduce期间资源需求变化很大&lt;/p>
&lt;p>已有的解决方案：只解决了Map-Only job，整套的MapReduce待解决&lt;/p>
&lt;h3 id="线性代数">线性代数&lt;/h3>
&lt;p>背景：并行数量在计算期间变化很大，移植到serverless computing可以提高执行速度并且提高资源利用率&lt;/p>
&lt;p>已有的解决方案：Numpywren&lt;/p>
&lt;h3 id="machine-learning">Machine learning&lt;/h3>
&lt;p>背景：预处理，模型训练等不同阶段的资源需求变化大，与线性代数类似&lt;/p>
&lt;p>已有的解决方案：Cirrus&lt;/p>
&lt;h3 id="database不太好解决">Database（不太好解决）&lt;/h3>
&lt;p>背景：使用cloud function来进行数据存储，但是需要存储服务的支持（Backend）；但是数据库连接又需要特定协议，从函数层面上不到网络层这一层；&lt;/p>
&lt;h2 id="references收集">References收集&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.symphonia.io/posts/2017-11-14_learning-lambda-part-8">https://blog.symphonia.io/posts/2017-11-14_learning-lambda-part-8&lt;/a> Learning Lambda — Part 8 cold starts&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.symphonia.io/posts/2020-06-30_analyzing_cold_start_latency_of_aws_lambda">https://blog.symphonia.io/posts/2020-06-30_analyzing_cold_start_latency_of_aws_lambda&lt;/a> Analyzing Cold Start latency of AWS Lambda&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://archive.fosdem.org/2020/schedule/event/containers_bpf/">https://archive.fosdem.org/2020/schedule/event/containers_bpf/&lt;/a> BPF as a revolutionary technology for the container landscape&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/cncf/wg-serverless/tree/master/whitepapers/serverless-overview">https://github.com/cncf/wg-serverless/tree/master/whitepapers/serverless-overview&lt;/a> CNCF Serverless Whitepaper v1.0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Farxiv.org%2Fpdf%2F2010.07115.pdf&lt;/p>
&lt;p>SSVM——WebAssembly Virtual machine&lt;/p>
&lt;/li>
&lt;/ul>
- https://jessestutler.github.io/posts/serverless%E5%88%86%E6%9E%90/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Raft</title><link>https://jessestutler.github.io/posts/raft/</link><pubDate>Tue, 09 Mar 2021 16:30:52 +0800</pubDate><guid>https://jessestutler.github.io/posts/raft/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/raft/ -&lt;h1 id="raft">Raft&lt;/h1>
&lt;h2 id="引言">引言&lt;/h2>
&lt;p>Raft是分布式数据一致性算法，用于解决PAXOS多年来晦涩难懂且难以工程复现的问题，本文对Raft发表的原文论文进行了大致解读&lt;/p>
&lt;h2 id="基本算法内容">基本算法内容&lt;/h2>
&lt;h3 id="basics">Basics&lt;/h3>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8plfwpl8j30ef05o0t3.jpg" alt="图 5">&lt;/p>
&lt;h4 id="followercandidateleader">Follower,Candidate,Leader&lt;/h4>
&lt;p>每个server分为三种状态（状态转换图见Leader election）：&lt;/p>
&lt;ul>
&lt;li>Follower：只接受RPC请求（就算收到来自client的请求也会重定向给leader）&lt;/li>
&lt;li>Candidate：参加竞选，可以发送RequestVote RPC，同样也可以接受请求&lt;/li>
&lt;li>Leader（only one）：&lt;strong>只有Leader可以处理来自client的请求&lt;/strong>，可以发送AppendEntries RPC，可以是追加日志条目用，也可以是心跳检测用（定期检测其他server是否还活着，通过&lt;strong>无条目追加&lt;/strong>的AppendEntries RPC来做到）&lt;/li>
&lt;/ul>
&lt;h4 id="term任期">term——任期&lt;/h4>
&lt;p>Raft将时间随机划分，每一段称为&lt;strong>任期&lt;/strong>（任期是单调递增的），任期都以一次选举开始，选举可以是选出leader也可以是未能选出leader（未能选出leader就直接进入下一任期）&lt;/p>
&lt;p>&lt;strong>每台server发现自己的任期小于其他机器就需要update到最新&lt;/strong>&lt;/p>
&lt;h4 id="entry条目">entry——条目&lt;/h4>
&lt;p>条目就是指日志的条目，由client发来的&lt;code>command+任期数（term number，用来检测不一致性）+index（条目索引）&lt;/code>构成&lt;/p>
&lt;h3 id="leader-election">Leader election&lt;/h3>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8pln7a9hj30hn07x0tq.jpg" alt="图 4 ">&lt;/p>
&lt;p>状态转换图分析：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Starts up:&lt;/p>
&lt;p>初始时，每台server都是Follower&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Follower&amp;mdash;&amp;gt;Candidate：&lt;/p>
&lt;p>当超出election timeout时间（长时间未收到有Leader发过来的RPC消息，说明当前cluster未选出leader，或者是未收到来自candidate的RequestVote RPC），Follower增加自己的当前任期数，并将自己转换为Candidate；参加竞选leader，给自己投票，然后并发地向其他server发送RequestVote RPC请求，需要他们给自己进行投票（&lt;strong>一般规则是先收到谁请求就投谁&lt;/strong>）；重设election timeout&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Candidate&amp;mdash;&amp;gt;Candidate：&lt;/p>
&lt;ul>
&lt;li>选举发生投票分歧&lt;/li>
&lt;/ul>
&lt;p>未能选出leader（发生投票分歧），比如有好几台Candidates票数一致的情况，或者大家都是Candidate（不可能给竞争对手投票是吧:P ），增加自己的当前任期数，并开始新一轮的选举。不过这样有可能造成一直产生投票分歧的情况，打破这种情况并选出leader的机制就是&lt;strong>election timeout，Candidates从时间段中随机给自己选一个election timeout时间，如果发生投票分歧，先超时的Candidate赢得选举&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Candidate收到Leader（已经暂时选出的）的RPC请求，发现其任期比自己旧，拒绝请求并保持Candidate状态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Candidate&amp;mdash;&amp;gt;Leader：&lt;/p>
&lt;p>赢得竞选（获得&lt;strong>大多数&lt;/strong>servers的投票）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Leader&amp;mdash;&amp;gt;Follower:&lt;/p>
&lt;p>通过RPC的回复发现自己的任期已过期（有比自己更新的任期），退回到Follower&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Candidate&amp;mdash;&amp;gt;Follower：&lt;/p>
&lt;ul>
&lt;li>输掉选举（收到了来自己已选出的leader的RPC，&lt;strong>但要确定自己的任期至少和Leader的任期相同，参考第3步&lt;/strong>）&lt;/li>
&lt;li>通过RPC的回复发现自己的任期已过期（有比自己更新的任期），退回到Follower&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="log-replication">Log Replication&lt;/h3>
&lt;p>&lt;strong>首先要说明的是，Leader只追加条目（entry）而不修改或删除entry&lt;/strong>&lt;/p>
&lt;p>Leader通过AppendEntries RPC来加条目复制到其他servers上，如果有server挂了他也会一直重复尝试发送。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Follower如何确定自己Leader发过来的条目可以追加？&lt;/p>
&lt;p>Leader发送的条目会包括索引号和任期数，如果Follwer没有找到相同索引号和任期数的条目，就拒绝请求，找到了就说明这个条目之前的条目都是相同的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>条目什么时候应该被apply到各个机器上？&lt;/p>
&lt;p>我们称之为&lt;strong>提交&lt;/strong>（commited），当条目&lt;strong>已经被复制到大多数的servers&lt;/strong>上（维护一个replicas来确定），这些条目（包括之前的未提交的条目，前leader剩下的未提交的条目）就都会被提交，每台server都会维护一个highest index表示最后的已经提交的条目，已表示这之前的条目都已提交&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="leader-crash所导致的log不一致问题">Leader crash所导致的log不一致问题&lt;/h3>
&lt;p>这个就是关键要解决的，Leader崩溃（然后发生Leader exchange）可能会导致一系列各server上&lt;strong>log不一致&lt;/strong>的问题（前leader可能还未完全复制给所有机器），&lt;strong>Follower可能会带有现Leader没有的log，或者更复杂的不一致问题&lt;/strong>，那如何解决呢？&lt;/p>
&lt;p>&lt;strong>覆盖&lt;/strong>。&lt;/p>
&lt;p>如果有不一致的log，Leader需要找到和Follower的日志中相同的&lt;strong>最后一个条目&lt;/strong>（也就是索引号和任期数相同，说明之前的条目都相同），然后将后面不一样的条目都&lt;strong>覆盖成Leader的&lt;/strong>（当然缺少的话就直接追加）。&lt;/p>
&lt;blockquote>
&lt;p>解决方法：当新leader出现时，他会先进行一致性检查，他会维护一个nextIndex，表示下一个要发送给follower的条目的索引号，当follower拒绝追加请求时（发现不一致），leader就减小nextIndex的大小，&lt;strong>直到条目相同为止&lt;/strong>，然后leader把这之后的条目全部覆盖掉Follower的日志&lt;/p>
&lt;/blockquote>
&lt;h3 id="safety">Safety&lt;/h3>
&lt;p>当leader提交的时候万一发生Follower崩溃的情况，而Follower复原之后又当上新leader，可能会出现覆盖之前已经提交的entry的情况，继而造成不同server最后执行了不同command的情况&lt;/p>
&lt;blockquote>
&lt;p>解决方法：加上election restriction，对于candidate&lt;strong>必须要涵盖之前已经所有已经提交的entry&lt;/strong>，也就是说就算candidate获得了大多数票数的情况下，必须以涵盖所有已提交entry为前提，否则不能赢得选举&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>那如何保证candidate涵盖了所有已经提交的条目呢？&lt;/p>
&lt;p>candidate的日志必须是最新的（up-to-date）。怎样规定最新呢？两个server的日志如果任期更新者就是最新的，或者任期相同而拥有更长索引者就是最新的。如果candidate发送RequestVote RPC，&lt;strong>而其log不比voter新，voter就要拒绝投票给candidate&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>还有的情况是，旧leader未能提交entry，而新leader也无法确定这个entry是否已提交&lt;/p>
&lt;blockquote>
&lt;p>leader只为当前任期是否应该提交维护一个replicas，也就是replicas如果是大多数的话就提交&lt;/p>
&lt;/blockquote>
&lt;h3 id="follower-and-candidate-crashes">Follower and candidate crashes&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>当Follower和candidate崩溃时，Leader会一直无限期的重发RPC直到它们重启并成功收到为止&lt;/p>
&lt;/li>
&lt;li>
&lt;p>保证幂等性：如果server在响应RPC前崩溃，要保证恢复后RPC的响应结果是一样的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="timing-and-availability">Timing and availability&lt;/h3>
&lt;blockquote>
&lt;p>广播时间 &amp;laquo; 选举超时时间 &amp;laquo; 平均崩溃时间&lt;/p>
&lt;/blockquote>
&lt;p>系统的时间要遵循上述不等式，第一个不等式避免Follower收不到心跳消息而转而变成Candidate状态进入新的选举，第二个不等式避免一直无法选出Leader&lt;/p>
&lt;p>广播时间和平均崩溃时间由现实决定，&lt;strong>选举超时时间一般在10ms到500ms之间&lt;/strong>&lt;/p>
&lt;h2 id="优化">优化&lt;/h2>
&lt;h3 id="cluster-membership-changes">Cluster membership changes&lt;/h3>
&lt;p>如果集群需要更改配置，比如替换掉原来的机器或者加入新机器，先将集群停掉，更改完配置之后再上线会让集群有段时间不可用，但是如果直接将旧配置改为新配置有可能会造成集群同时出现两个leader的情况。Raft用一种两阶段算法，引入了一个过渡配置——共同一致，集群同时可以有旧配置和新配置的存在，但需要进行一定的限制，具体参考：https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md#6-%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E5%8F%98%E5%8C%96&lt;/p>
&lt;h3 id="log-compaction">Log compaction&lt;/h3>
&lt;p>避免存储日志过多（提交了之后的日志条目会占用过多磁盘空间，其实只要保留一点metadata用来标识和回滚就够了）&lt;/p>
&lt;blockquote>
&lt;p>解决方法：snapshot（快照），&lt;strong>由每台server自己&lt;/strong>将已经提交的条目信息用metadata的形式记录下来形成snapshot，然后就可以把已经提交的日志条目丢弃了，这样就可以减少日志占用的空间，而且方便一致性检查，就是我们前文提到的当leader crash时出现的一系列问题，可以快速检索metadata获取最后提交的条目信息&lt;/p>
&lt;/blockquote>
&lt;p>这里引入一个InstallSnapshot RPC，当出现server已经提交而Follower还未提交的情况（比如刚刚加入集群的机器或者比较慢的未收到entry的机器），这时候Follower的snapshot是远远落后的&lt;/p>
&lt;h3 id="client-interaction">client interaction&lt;/h3>
&lt;p>client是随机请求集群中的server，不一定是leader，如果是Follower收到了请求他会重定向给Leader（AppendEntries RPC中包含了Leader的地址）&lt;/p>
&lt;p>当Leader已经执行了client的请求发来的command，但是响应client前崩溃，client可能会重新提交这个command的请求，造成两次执行同样的command，我们需要给每个command维护一个serial number，表示command序列，当已经执行过了这个serial number的command，收到同样的请求就不再执行&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;p>&lt;a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md&lt;/a>（论文中文翻译和原文）&lt;/p>
&lt;p>&lt;a href="https://raft.github.io/">https://raft.github.io/&lt;/a>（raft概述和动画演示，以及论文原文下载）&lt;/p>
- https://jessestutler.github.io/posts/raft/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Golang基础</title><link>https://jessestutler.github.io/posts/golang%E5%9F%BA%E7%A1%80/</link><pubDate>Sun, 07 Mar 2021 11:25:55 +0800</pubDate><guid>https://jessestutler.github.io/posts/golang%E5%9F%BA%E7%A1%80/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/golang%E5%9F%BA%E7%A1%80/ -&lt;h1 id="golang">GOLANG&lt;/h1>
&lt;h2 id="引言">引言&lt;/h2>
&lt;p>云原生体系下，golang一定是必须要掌握的高级语言，golang内置的goroutine契合分布式架构的设计，越来越多的关于云的开源项目采用go进行实现。本文参考：http://c.biancheng.net/golang/intro/ ，本文对go的基础知识进行了大致介绍，可参照右侧的大纲检索，本文会持续更新。&lt;/p>
&lt;p>这里笔者也推荐一些go练手项目：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://geektutu.com/post/gee.html">https://geektutu.com/post/gee.html&lt;/a> 极客兔兔的7天用go从零实现系列（必须强烈推荐👍，一天天打下来能对很多go的开源项目有个大致的认识，也能学到很多技巧）&lt;/li>
&lt;li>&lt;a href="https://courses.calhoun.io/courses">https://courses.calhoun.io/courses&lt;/a> 需要挂梯子，作为一些对于go不同的包的练手项目不错&lt;/li>
&lt;/ul>
&lt;h1 id="heading">&lt;/h1>
&lt;h2 id="常用命令">常用命令&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>go install [package-name]&lt;/p>
&lt;p>编译并安装包，如果不是main包则会安装到pkg底下作为库包，如果是main包则会安装到bin底下作为可执行文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>go doc [package] [func]&lt;/p>
&lt;p>go手册&lt;/p>
&lt;/li>
&lt;li>
&lt;p>go build [file or package]&lt;/p>
&lt;p>如果是main包，生成可执行文件（可执行文件名同文件夹名），如果不是main包，不生成可执行文件，只进行编译&lt;/p>
&lt;p>如果是单个.go文件，main包中&lt;strong>只能对含main函数&lt;/strong>的go文件进行编译并生成可执行文件，其他包只进行编译&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="go-module">go module&lt;/h3>
&lt;p>&lt;strong>以后默认用go module的方式进行包管理和添加依赖，以后workspace不必在GOPATH下，GOPATH就存放下载的包和编译好的课执行文件&lt;/strong>&lt;/p>
&lt;p>root workspace底下有两个文件，一个是go.mod（包管理），一个是go.sum（包校验），真正的包下载好放在$GOPATH/pkg/mod底下&lt;/p>
&lt;p>&lt;strong>在root workspace底下&lt;/strong>用&lt;code>go mod init[模块名]&lt;/code>生成go.mod，模块名命名格式为example.com/xxx..（一般就github.com/foo这样），然后引用workspace底下子目录的go文件，用&lt;code>模块名/子目录名&lt;/code>的格式引用&lt;/p>
&lt;p>==给项目添加依赖（写进 go.mod)的两种方法==：&lt;/p>
&lt;ul>
&lt;li>你只要在项目中有 import，然后 go build 就会 go module 就会自动下载并添加（&lt;strong>perfect way&lt;/strong>）&lt;/li>
&lt;li>自己手工使用 go get 下载安装后，会自动写入 go.mod&lt;/li>
&lt;/ul>
&lt;h4 id="常用命令-1">常用命令&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>go mod init&lt;/p>
&lt;p>初始化module&lt;/p>
&lt;/li>
&lt;li>
&lt;p>go mod tidy&lt;/p>
&lt;p>下载缺少的包，清除没有用上的包&lt;/p>
&lt;/li>
&lt;li>
&lt;p>go list&lt;/p>
&lt;p>-m all列出所有模块&lt;/p>
&lt;p>-u -m all列出所有模块及其可能拥有的更新&lt;/p>
&lt;/li>
&lt;li>
&lt;p>go get -u [module] 更新模块及其依赖到最新版本&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="变量命名方式">变量命名方式&lt;/h2>
&lt;blockquote>
&lt;p>简短变量声明被广泛用于大部分的局部变量的声明和初始化。var 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>一般以 &lt;code>变量名:=变量值&lt;/code>的形式由编译器自行判断类型并赋值（适用于局部变量，用在初始化的时候，注意是**:=而不是=，左部变量必须未定义，否则会产生编译错误**），==局部变量不可重复声明，声明的变量没有使用也会编译错误(import包如果没有用到也会报错，与java给个警告不同==全局变量可以声明但不使用，或以&lt;code>var 变量名 type = 变量值&lt;/code>（var 变量名 = 变量值，自动识别）的形式赋值（适用于全局变量，用在暂时不需要初始化只需要声明的时候，&lt;strong>go也会给未进行初始化的变量赋值&lt;/strong>）。&lt;/li>
&lt;li>在同一行同时赋值，编译器会根据顺序将右边的值依次赋予给左边的变量，e.g：&lt;/li>
&lt;/ul>
&lt;p>a,b,c := 1,2,&amp;ldquo;hello&amp;rdquo;，也适用于一个函数有&lt;strong>多个返回值&lt;/strong>时&lt;/p>
&lt;ul>
&lt;li>
&lt;p>交换值a,b=b,a&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>匿名变量&lt;/strong>的特点是一个下画线“_”，本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。e.g:&lt;/p>
&lt;p>&lt;code>a, _ := GetData()&lt;/code>当函数有多个返回值但是暂时不需要赋给这么多变量时，用“_&amp;ldquo;吞掉返回的值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>go中使用==或者!=等进行比较时，&lt;strong>两边的变量类型必须相同&lt;/strong>，不相同必须进行强制类型转换（&lt;strong>注意bool无法与其他类型强转&lt;/strong>）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>双引号声明字符串字面量不能跨行，需要用反引号`，多行字符串一般用于内嵌源码和内嵌数据等（换行会被保留，但是无法用转义）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>rune类型代表一个utf-8字符&lt;/strong>，它同等于int32，byte可表示一个ASCII字符，它同等于uint8&lt;/p>
&lt;/li>
&lt;li>
&lt;p>类型转换：go没有隐式转换，需要声明类型转换，valueOfTypeB = typeB(valueOfTypeA)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>iota（多用于枚举，多常量声明形式，如以下代码，每显式声明一个const（或组） ，iota都会初始化为0，const组中每增加一行，iota就加1（常用于信号量/标识）：&lt;/p>
&lt;pre tabindex="0">&lt;code>const (
Sunday = iota （Sunday=0）
Monday （如果const中没有显式赋值，则赋值为前一行的值，即iota）
Tuesday
Wednesday
Thursday
Friday
Saturday
)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>类型别名：type TypeAlias = Type （TypeAlias仍然是Type型，只不过取了别名）&lt;/p>
&lt;p>类型定义： type TypeAlias Type （没有等号，相当于C语言中的typedef，TypeAlias是一个新类型了，&lt;strong>常用于结构体定义&lt;/strong>）&lt;/p>
&lt;p>类型断言：因为接口变量的动态类型是变化的，有时我们需要知道一个接口变量的动态类型究竟是什么，这就需要使用类型断言，断言就是对接口变量的类型进行检查，其语法结构如下：（&lt;strong>可以用于interface{}类型变量转换为其他类型变量&lt;/strong>），==具体参考反射章节==&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>value, ok := x.(T)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x表示要断言的接口变量&lt;span style="color:#a61717;background-color:#e3d2d2">；&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>T表示要断言的目标类型&lt;span style="color:#a61717;background-color:#e3d2d2">；&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>value表示断言成功之后目标类型变量&lt;span style="color:#a61717;background-color:#e3d2d2">；&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ok表示断言的结果&lt;span style="color:#a61717;background-color:#e3d2d2">，&lt;/span>是一个bool型变量&lt;span style="color:#a61717;background-color:#e3d2d2">，&lt;/span>true表示断言成功&lt;span style="color:#a61717;background-color:#e3d2d2">，&lt;/span>false表示失败&lt;span style="color:#a61717;background-color:#e3d2d2">，&lt;/span>如果失败value的值为nil&lt;span style="color:#a61717;background-color:#e3d2d2">。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>指针不能进行偏移和运算&lt;/strong>（==安全==）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数变量：类型为func([参数类型] [,参数类型……])[返回类型]&lt;/p>
&lt;p>（&lt;strong>一般会给函数变量的类型定义一个其他类型，方便标识&lt;/strong>）&lt;/p>
&lt;p>函数变量常常用于搭配匿名函数接收回调函数，&lt;strong>使用了回调函数，可以增加灵活性（具体函数由调用主体实现，被调用者只用函数变量来接收参数）&lt;/strong>&lt;/p>
&lt;p>e.g:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// 遍历切片的每个元素, 通过给定函数进行元素访问
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">visit&lt;/span>(list []&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>, f &lt;span style="color:#8b008b;font-weight:bold">func&lt;/span>(&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> _, v := &lt;span style="color:#8b008b;font-weight:bold">range&lt;/span> list {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008b45">f&lt;/span>(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// 使用匿名函数打印切片内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#008b45">visit&lt;/span>([]&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>{&lt;span style="color:#b452cd">1&lt;/span>, &lt;span style="color:#b452cd">2&lt;/span>, &lt;span style="color:#b452cd">3&lt;/span>, &lt;span style="color:#b452cd">4&lt;/span>}, &lt;span style="color:#8b008b;font-weight:bold">func&lt;/span>(v &lt;span style="color:#00688b;font-weight:bold">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>interface{}空接口类型能够接受任意类型变量，==因为interface{}不包含任何函数，所以任何类型都实现了空接口==，interface的底层实际上是eface结构体，==具体参考反射章节中的引用==&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> eface &lt;span style="color:#8b008b;font-weight:bold">struct&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _type *_type
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data unsafe.Pointer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="项目目录说明">项目目录说明&lt;/h2>
&lt;blockquote>
&lt;p>src：用于以包（package）的形式组织并存放 Go 源文件，这里的包与 src 下的每个子目录是一一对应。例如，若一个源文件被声明属于 log 包，那么它就应当保存在 src/log 目录中。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>同一个目录下所有的go文件只能有一个包名（package相同）,&lt;strong>但是包名可以与目录名不同（最好是建议相同）&lt;/strong>&lt;/li>
&lt;li>main 包是Go语言程序的入口包，main函数是入口函数，只有package main的go文件能包含main函数（&lt;strong>有且仅有一个&lt;/strong>），一个Go语言程序必须&lt;strong>有且仅有一个&lt;/strong> main 包。如果一个程序没有 main 包，那么编译时将会出错，无法生成可执行文件&lt;/li>
&lt;li>==&lt;strong>使用大小写来决定常量，变量，函数等是否可以被外部包所使用，首字母大写就相当于public，首字母小写就相当于private&lt;/strong>==&lt;/li>
&lt;/ul>
&lt;h2 id="条件循环语句">条件，循环语句&lt;/h2>
&lt;p>&lt;strong>if 语句使用 tips&lt;/strong>&lt;/p>
&lt;p>&lt;strong>（1）&lt;/strong> 不需使用括号将条件包含起来&lt;/p>
&lt;p>&lt;strong>（2）&lt;/strong> &lt;strong>大括号{}必须存在，即使只有一行语句&lt;/strong>&lt;/p>
&lt;p>&lt;strong>（3）&lt;/strong> &lt;strong>左括号必须在if或else的同一行，if的右括号要与else同一行（或者有多个else if的话）&lt;/strong>&lt;/p>
&lt;p>&lt;strong>（4）&lt;/strong> &lt;strong>在if之后，条件语句之前，可以添加变量初始化语句，使用；进行分隔&lt;/strong>(==常用于接收条件==)&lt;/p>
&lt;p>&lt;strong>（5）&lt;/strong> 在有返回值的函数中，最终的return不能在条件语句中&lt;/p>
&lt;p>&lt;strong>for&lt;/strong>&lt;/p>
&lt;p>&lt;strong>（1）&lt;/strong> 不需要使用括号&lt;/p>
&lt;p>&lt;strong>（2）&lt;/strong> 没有while语句，for condition {}相当于while，for{}相当于while(1)&lt;/p>
&lt;p>&lt;strong>switch&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">var&lt;/span> a = &lt;span style="color:#cd5555">&amp;#34;hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">switch&lt;/span> a {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">case&lt;/span> &lt;span style="color:#cd5555">&amp;#34;hello&amp;#34;&lt;/span>,&lt;span style="color:#cd5555">&amp;#34;cello&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(&lt;span style="color:#b452cd">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">case&lt;/span> &lt;span style="color:#cd5555">&amp;#34;world&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(&lt;span style="color:#b452cd">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(&lt;span style="color:#b452cd">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>（1）&lt;strong>case与case是独立的代码块，不需要break&lt;/strong>&lt;/p>
&lt;p>（2）case的判断可以是表达式也可以多值，如上所示&lt;/p>
&lt;p>&lt;strong>type-switch&lt;/strong>&lt;/p>
&lt;p>用来判断接口变量的类型，有点Scala的感觉&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">switch&lt;/span> 接口变量.(&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">case&lt;/span> 类型1:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// 变量是类型1时的处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">case&lt;/span> 类型2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// 变量是类型2时的处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">…&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// 变量不是所有case中列举的类型时的处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>是某个case的类型就匹配，否则匹配default&lt;/p>
&lt;p>&lt;strong>select&lt;/strong>&lt;/p>
&lt;p>结构类似switch，但是如果有多个同时case匹配，switch是顺序执行，==select是随机执行==，&lt;strong>只能用于通道的读写&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>select循环一旦某个case匹配只会执行一次，可以通过在for{}循环中嵌套select来不断地监听通道，但是select中某个case使用&lt;strong>break只会退出当前select的执行，并不会退出外层for{}循环&lt;/strong>&lt;/li>
&lt;li>一般使用非阻塞收发，即存在default，否则select会阻塞goroutine，直到从goroutine中收发到数据为止&lt;/li>
&lt;li>当存在可以收发的channel时就执行对应的case，否则就执行default&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>break和continue&lt;/strong>&lt;/p>
&lt;p>go中的break有一项功能，就是可以跳到指定标签的循环，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>OuterLoop:&lt;span style="color:#228b22">//我这里给最外层循环打上了OuterLoop的标签
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> i := &lt;span style="color:#b452cd">0&lt;/span>; i &amp;lt; &lt;span style="color:#b452cd">2&lt;/span>; i++ {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> j := &lt;span style="color:#b452cd">0&lt;/span>; j &amp;lt; &lt;span style="color:#b452cd">5&lt;/span>; j++ {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">switch&lt;/span> j {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">case&lt;/span> &lt;span style="color:#b452cd">2&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(i, j)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">break&lt;/span> OuterLoop&lt;span style="color:#228b22">//这里就不是跳出内层循环了，而是直接跳出最外层循环
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">case&lt;/span> &lt;span style="color:#b452cd">3&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(i, j)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">break&lt;/span> OuterLoop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>continue同理，跳到指定标签循环的下一次循环&lt;/p>
&lt;h2 id="函数">函数&lt;/h2>
&lt;pre tabindex="0">&lt;code>func function_name( [parameter list] ) [return_types] {
函数体
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>函数可以返回多值&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>未定义长度的数组只能传给不限制数组长度的函数，定义了长度的数组只能传给限制了相同数组长度的函数&lt;/li>
&lt;/ul>
&lt;p>匿名函数&lt;/p>
&lt;ul>
&lt;li>匿名函数就是没有定义函数名的函数，可以传给函数变量&lt;/li>
&lt;/ul>
&lt;p>闭包(closure)&lt;/p>
&lt;ul>
&lt;li>闭包函数是高阶函数中的内部函数，其需要等待高阶函数捕获自由变量之后才能生成，其有点像生成模板一样，先写了些代码逻辑，确定了一部分功能，等到捕获自由变量之后就能生成另一部分功能了&lt;/li>
&lt;/ul>
&lt;p>defer（延迟执行语句）&lt;/p>
&lt;ul>
&lt;li>延迟调用函数是&lt;strong>在 defer 所在函数结束前进行（包括panic之后），return后进行&lt;/strong>。常使用在释放资源时，比如关闭文件，解锁等等。如果有多个defer，&lt;strong>defer会串成一个链表，依次逆序调用（写在最后面的最先被执行），相当于一个栈。&lt;/strong>==defer链表只与当前goroutine相关联==&lt;/li>
&lt;li>&lt;strong>defer的函数传参是立马计算&lt;/strong>，并不是在当前函数退出之前计算&lt;/li>
&lt;li>recover只能通过defer发生作用&lt;/li>
&lt;li>panic只会触发当前goroutine的defer函数&lt;/li>
&lt;/ul>
&lt;p>接口型函数&lt;/p>
&lt;ul>
&lt;li>
&lt;p>接口型函数在大量开源go项目中使用到，参考：&lt;a href="https://geektutu.com/post/7days-golang-q1.html%EF%BC%8C%E7%AE%80%E5%8D%95%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3**%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95**%EF%BC%8C%E8%80%8C%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%88**%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E9%83%BD%E8%A6%81%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%90%8C**%EF%BC%8C%E7%84%B6%E5%90%8E%E5%AE%9E%E7%8E%B0%E6%97%B6%E8%B0%83%E7%94%A8%E8%87%AA%E5%B7%B1%EF%BC%89%E3%80%82%E8%BF%99%E6%A0%B7%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%8B%BF%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%EF%BC%8C%E6%97%A2%E5%8F%AF%E4%BB%A5%E4%BC%A0%E5%85%A5%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%AF%E4%BB%A5%E5%A2%9E%E5%8A%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%96%B9%E6%B3%95%E6%89%A9%E5%85%85%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%89%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BC%A0%E5%85%A5%E6%8E%A5%E5%8F%A3%E5%9E%8B%E5%87%BD%E6%95%B0%EF%BC%88%E9%9C%80%E8%A6%81%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%89%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%8D%95%E5%8D%95%E5%8F%AA%E6%98%AF%E5%8E%9F%E6%9D%A5%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E4%B8%AA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AE%A9%E7%94%A8%E6%88%B7%E5%AE%9E%E7%8E%B0%E3%80%82e.g">https://geektutu.com/post/7days-golang-q1.html，简单就是说，一个接口&lt;strong>只有一个方法&lt;/strong>，而定义一个函数实现这个接口（&lt;strong>参数类型都要和接口中的方法的参数类型相同&lt;/strong>，然后实现时调用自己）。这样，就可以拿接口作为函数参数，既可以传入实现了接口的结构体（结构体可以增加自己的方法扩充接口的功能），也可以传入接口型函数（需要强制类型转换），而不单单只是原来定义了一个回调函数参数让用户实现。e.g&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// A Getter loads data for a key.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> Getter &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008b45">Get&lt;/span>(key &lt;span style="color:#00688b;font-weight:bold">string&lt;/span>) ([]&lt;span style="color:#00688b;font-weight:bold">byte&lt;/span>, &lt;span style="color:#00688b;font-weight:bold">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// A GetterFunc implements Getter with a function.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> GetterFunc &lt;span style="color:#8b008b;font-weight:bold">func&lt;/span>(key &lt;span style="color:#00688b;font-weight:bold">string&lt;/span>) ([]&lt;span style="color:#00688b;font-weight:bold">byte&lt;/span>, &lt;span style="color:#00688b;font-weight:bold">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// Get implements Getter interface function
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> (f GetterFunc) &lt;span style="color:#008b45">Get&lt;/span>(key &lt;span style="color:#00688b;font-weight:bold">string&lt;/span>) ([]&lt;span style="color:#00688b;font-weight:bold">byte&lt;/span>, &lt;span style="color:#00688b;font-weight:bold">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> &lt;span style="color:#008b45">f&lt;/span>(key)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>==对于切片，map，channel的拷贝都是浅拷贝（只拷贝了引用，底层数据未拷贝）==&lt;/p>
&lt;ul>
&lt;li>函数传参和返回都会发生拷贝&lt;/li>
&lt;/ul>
&lt;h2 id="数组和切片">数组和切片&lt;/h2>
&lt;p>==切片相当于一个窗口，是对底层数组的引用==&lt;/p>
&lt;p>切片就是动态数组，可以动态扩展容量，无需指定大小，它有三个元素：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>一个指针指向切片的开始位置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Len，切片的实际长度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cap，底层数组的最大长度（只能向后看）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>切片如果改变元素是会对所有引用及原数组改变的，因为他实际是一个指针&lt;/strong>&lt;/p>
&lt;p>数组初始化方法，例： arr := [3]int{3,4,5}（==数组大小必须固定==），[&amp;hellip;]type可以根据初始化的个数来判断大小&lt;/p>
&lt;p>切片初始化方法，例：arr := []int{3,4,5}（没指定大小）&lt;/p>
&lt;h3 id="数组中取元素给切片或切片元素给其他切片">数组中取元素给切片(或切片元素给其他切片)&lt;/h3>
&lt;p>比如有一个数组a，他是[n]int型数组&lt;/p>
&lt;p>a[x:y]表示：从a[x]取起到a[y-1]，x为开始索引，y为结束索引（取到y-1）&lt;/p>
&lt;p>不填x和y，默认第一个为0，第二个为n&lt;/p>
&lt;ul>
&lt;li>a[:]，同等a[0:n]，即获取a中所有元素&lt;/li>
&lt;li>a[x:]从a&lt;input checked="" disabled="" type="checkbox"> 取起到a[n]&lt;/li>
&lt;li>a[:y]从a[0]开始取其到a[y-1]&lt;/li>
&lt;li>a[0:0]切片清空&lt;/li>
&lt;/ul>
&lt;h3 id="创建切片的方法">创建切片的方法&lt;/h3>
&lt;p>==创建新切片==&lt;/p>
&lt;ol>
&lt;li>
&lt;p>普通方法创建：&lt;/p>
&lt;p>创建切片也是通过先创建数组然后再通过指针创建的&lt;/p>
&lt;p>&lt;code>var arr []int&lt;/code>，切片为nil，无元素&lt;/p>
&lt;p>&lt;code>arr := []int{1,2,3}&lt;/code>有初始化元素&lt;/p>
&lt;/li>
&lt;li>
&lt;p>make函数创建（初始化切片元素到len的元素为0）：&lt;/p>
&lt;p>&lt;code>slice1 := make([]type, len,[cap])&lt;/code>，省略cap默认等于len，cap就是底层数组的大小&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>==引用原数组或原切片的一部分==&lt;/p>
&lt;ol>
&lt;li>
&lt;p>引用另一个数组的一部分：&lt;/p>
&lt;p>s := arr[start:end],即引用原数组或原切片start到end-1的元素&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="切片中追加元素">切片中追加元素&lt;/h3>
&lt;p>切片追加元素用append(切片名，元素)，要考虑append会不会超过cap：&lt;/p>
&lt;p>1）如果没超过cap，则仍是返回旧切片（引用旧数组）&lt;/p>
&lt;p>2）如果超过cap，遵循一定规则增加容量，参考《GO语言设计与实现》P65，==一定会返回新切片（引用新数组）==&lt;/p>
&lt;p>&lt;strong>tips:&lt;/strong>(&amp;rdquo;&amp;hellip;&amp;ldquo;三个点表示任意参数)&lt;/p>
&lt;p>&lt;strong>使用 slice&amp;hellip;表示slice中的所有元素，方便用于append&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>slice1=&lt;span style="color:#658b00">append&lt;/span>(slice1,slice2...) &lt;span style="color:#228b22">//slice2中的元素一个个追加入slice1中，这样不用一个个写出来了
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="切片复制">切片复制&lt;/h3>
&lt;p>&lt;code>copy( destSlice, srcSlice)&lt;/code>，从源切片（可以是部分）拷贝到目标切片，注意此深拷贝不会扩容，如果要深拷贝一个新切片出来，可以使用&lt;code>dest_slice := append([]int{},src_slice...)&lt;/code>&lt;/p>
&lt;h3 id="切片删除元素">切片删除元素&lt;/h3>
&lt;p>原地append（元素前移法）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>a = []&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>{&lt;span style="color:#b452cd">1&lt;/span>, &lt;span style="color:#b452cd">2&lt;/span>, &lt;span style="color:#b452cd">3&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a = &lt;span style="color:#658b00">append&lt;/span>(a[:&lt;span style="color:#b452cd">0&lt;/span>], a[&lt;span style="color:#b452cd">1&lt;/span>:]...) &lt;span style="color:#228b22">// 删除开头1个元素（把第1个截掉，后面元素追加上来）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>a = &lt;span style="color:#658b00">append&lt;/span>(a[:&lt;span style="color:#b452cd">0&lt;/span>], a[N:]...) &lt;span style="color:#228b22">// 删除开头N个元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a = &lt;span style="color:#658b00">append&lt;/span>(a[:i], a[i+&lt;span style="color:#b452cd">1&lt;/span>:]...) &lt;span style="color:#228b22">// 删除中间1个元素（截到中间那个元素前，然后把中间后面的元素追加上来）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>a = &lt;span style="color:#658b00">append&lt;/span>(a[:i], a[i+N:]...) &lt;span style="color:#228b22">// 删除中间N个元素
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="range和for-each循环">range和for-each循环&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> key, value := &lt;span style="color:#8b008b;font-weight:bold">range&lt;/span> 数组或切片或map {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 代码块
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用range可以搭配for循环遍历数组、切片、map和字符串等，以key-value的形式返回（数组和切片的key是索引值），如果不需要key或者value可以用__占位符替代。使用range还可以搭配可变参数，e.g:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">myfunc&lt;/span>(args ...&lt;span style="color:#00688b;font-weight:bold">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> _, arg := &lt;span style="color:#8b008b;font-weight:bold">range&lt;/span> args {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(arg)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可变参数实际上就是一个切片，并且可以用&lt;code>args...&lt;/code>继续传给其他函数&lt;/p>
&lt;p>&lt;strong>tips:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>需要注意的是，value为值的拷贝，所以只具有可读性，对这个value值的改变不会改变原来集合中的值&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>for range遍历hash的顺序是不定的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="字符串">字符串&lt;/h2>
&lt;p>GO中的string是==只读==的，其有一个指向字节数组的指针和数组的大小&lt;/p>
&lt;p>&lt;strong>如果读写字符串&lt;/strong>，需要将其转换为[]byte&lt;/p>
&lt;p>Tips：&lt;/p>
&lt;ul>
&lt;li>如果字符串拼接次数多可以用strings.Builder声明变量，然后调用WriteString()方法，因为字符串拼接是会拷贝字符串的&lt;/li>
&lt;/ul>
&lt;h2 id="map">Map&lt;/h2>
&lt;p>参考：&lt;a href="https://www.cnblogs.com/qcrao-2018/p/10903807.html">深度解密Go语言之map - Stefno - 博客园&lt;/a>&lt;/p>
&lt;p>==注意键的类型要是可Hash的==&lt;/p>
&lt;h3 id="创建map">创建map&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;code>var 变量名 map[key_type]value_type&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用make函数创建：&lt;/p>
&lt;p>&lt;code>变量名 := make(map[key_type]value_type,[cap])&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>tips:&lt;/strong>&lt;/p>
&lt;p>&lt;strong>value_type可以是切片，这样一个key就对应多个value值了，例如：父进程的pid作为key，多个子进程的pid作为切片元素&lt;/strong>&lt;/p>
&lt;h3 id="map中追加元素">map中追加元素&lt;/h3>
&lt;p>直接key-value方法赋值即可&lt;/p>
&lt;h3 id="map删除元素">map删除元素&lt;/h3>
&lt;p>&lt;code>delete(map,key)&lt;/code>&lt;/p>
&lt;h3 id="map访问">map访问&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>v := &lt;span style="color:#8b008b;font-weight:bold">map&lt;/span>[key]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v,ok := &lt;span style="color:#8b008b;font-weight:bold">map&lt;/span>[key] &lt;span style="color:#228b22">//ok代表key的值是否存在,更推荐这种
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="containerlist">container/list&lt;/h2>
&lt;p>实现为双向循环链表&lt;/p>
&lt;p>list为element+len（链表长度，==不包括哨兵==），element才是具体节点，value是interface{}类型&lt;/p>
&lt;h3 id="创建链表">创建链表&lt;/h3>
&lt;p>&lt;code>变量 := list.New()&lt;/code>，New()返回一个*list，链表无节点，只有哨兵，len为0&lt;/p>
&lt;h3 id="链表中插入元素">链表中插入元素&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>这里head为*list&lt;span style="color:#a61717;background-color:#e3d2d2">，&lt;/span>代表链表的头
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>尾部插入&lt;span style="color:#a61717;background-color:#e3d2d2">：&lt;/span>head.&lt;span style="color:#008b45">PushBack&lt;/span>(任意类型元素)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>前部插入&lt;span style="color:#a61717;background-color:#e3d2d2">：&lt;/span>head.&lt;span style="color:#008b45">PushFront&lt;/span>(任意类型元素)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PushBack和PushFront都返回一个*Element&lt;span style="color:#a61717;background-color:#e3d2d2">，&lt;/span>用来方便在链表中插入节点
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>这里用mark表示PushBack或PushFront返回的*Element
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>在mark后插&lt;span style="color:#a61717;background-color:#e3d2d2">：&lt;/span>head.&lt;span style="color:#008b45">InsertAfter&lt;/span>(任意类型元素,mark)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>在mark前插&lt;span style="color:#a61717;background-color:#e3d2d2">：&lt;/span>head.&lt;span style="color:#008b45">InsertBefore&lt;/span>(任意类型元素,mark)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除链表元素">删除链表元素&lt;/h3>
&lt;p>&lt;code>head.Remove(mark)&lt;/code>&lt;/p>
&lt;h3 id="遍历链表元素">遍历链表元素&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> i := l.&lt;span style="color:#008b45">Front&lt;/span>(); i != &lt;span style="color:#8b008b;font-weight:bold">nil&lt;/span>; i = i.&lt;span style="color:#008b45">Next&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(i.Value)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">Front()表示获取第一个节点，Back()表是获取最后一个节点，Next()表示下一节点,Value获取节点值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="containerring和containerheap">container/Ring和container/heap&lt;/h2>
&lt;p>Ring也是双向循环链表，但是长度固定&lt;/p>
&lt;p>heap可以用来进行堆排序&lt;/p>
&lt;h2 id="指针">指针&lt;/h2>
&lt;p>指针的用法与c语言相同&lt;/p>
&lt;p>也可以用 new()函数来创建指针，例：var_name := new(type)，这样var_name保存的是type类型变量的首地址&lt;/p>
&lt;h2 id="结构体">结构体&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> 类型名 &lt;span style="color:#8b008b;font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 字段1 字段1类型
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 字段2 字段2类型
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717;background-color:#e3d2d2">…&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>tips:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>结构体中的字段可以内嵌其他结构体，被内嵌的结构体中的字段可以直接引用，而不用多层引用（有点像继承），e.g:&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>a.b.c.d可以直接用a.d&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>go中指针结构体中的字段可以直接引用（用了语法糖），而不用像C中一样用-&amp;gt;&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="结构体实例化方式">结构体实例化方式&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>以创建指针的方式&lt;/p>
&lt;p>&lt;code>ins := new(T)&lt;/code>&lt;/p>
&lt;p>其中T为结构体类型名，返回一个*T&lt;/p>
&lt;/li>
&lt;li>
&lt;p>取结构体的地址实例化&lt;/p>
&lt;p>&lt;code>ins := &amp;amp;T{}&lt;/code>&lt;/p>
&lt;p>同样返回一个*T，然后&lt;code>T.字段名&lt;/code>赋值，或者&lt;strong>指明字段的方式&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>ins := &amp;amp;结构体类型名{
字段1: 字段1的值,
字段2: 字段2的值,
…
}
&lt;/code>&lt;/pre>&lt;p>字段与字段之间用,分隔，这种方式某个字段可以省略，那么字段值取省略值&lt;/p>
&lt;p>或者&lt;strong>多值方式&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>ins := &amp;amp;结构体类型名{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 字段1的值,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 字段2的值,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717;background-color:#e3d2d2">…&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种方式省略字段名，但是所有结构体内的字段都必须赋值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>直接定义&lt;/p>
&lt;p>声明方式也是&lt;strong>指明字段和多值方式&lt;/strong>，只不过变量用的是T而不是*T而已&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="接口">接口&lt;/h2>
&lt;p>接口底层实现参考：&lt;a href="https://www.cnblogs.com/qcrao-2018/p/10766091.html">深度解密Go语言之关于 interface 的10个问题 - Stefno - 博客园&lt;/a>&lt;/p>
&lt;p>go中的接口是非侵入式的，不同于Java这些语言需要显式的进行implements接口，go类型实现接口不需要进行声明，只需要实现接口中的所有方法，所以类型中的方法是接口中方法的&lt;strong>超集&lt;/strong>。非侵入式的好处还在于，不同于面向对象接口需要根据业务来事先制定接口中的方法，&lt;strong>甚至可以先实现类型再声明接口&lt;/strong>，可扩展性强，而且如果以后想把接口中一些方法独立出来列为新接口，按照Java这些侵入式的方法，是需要重新implements新接口并且重新编译的。&lt;strong>而且，类型实现接口甚至不需要引入包&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> 接口类型名 &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 方法名1( 参数列表1 ) 返回值列表1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 方法名2( 参数列表2 ) 返回值列表2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717;background-color:#e3d2d2">…&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>参数&lt;strong>名&lt;/strong>和返回值&lt;strong>名&lt;/strong>都可以省略&lt;/p>
&lt;h3 id="实现接口">实现接口&lt;/h3>
&lt;p>e.g:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// 定义一个数据写入器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> DataWriter &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008b45">WriteData&lt;/span>(data &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span>{}) &lt;span style="color:#00688b;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// 定义文件结构，用于实现DataWriter
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> file &lt;span style="color:#8b008b;font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// 实现DataWriter接口的WriteData方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// 这里方法要指定接收者
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> (d *file) &lt;span style="color:#008b45">WriteData&lt;/span>(data &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span>{}) &lt;span style="color:#00688b;font-weight:bold">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// 模拟写入数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> fmt.&lt;span style="color:#008b45">Println&lt;/span>(&lt;span style="color:#cd5555">&amp;#34;WriteData:&amp;#34;&lt;/span>, data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>==注意接受者如果不是指针类型而是普通类型的话，在方法内修改实例的属性不会改变原实例的值，因为是拷贝，而指针指向了原实例==&lt;/p>
&lt;p>&lt;strong>tips:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>只有当实现了接口的类型赋值给接口变量时，编译器才会去比较这个类型中是否全部实现了接口中的方法&lt;/strong>&lt;/li>
&lt;li>内嵌结构体也能实现接口，这样外层结构体就不必再实现一次了，避免了冗余代码&lt;/li>
&lt;li>实现类型不能是&lt;strong>系统内置类型，只能是结构体或者是用type定义的新类型&lt;/strong>&lt;/li>
&lt;li>接口中可以像结构体一样嵌套接口，这样接口中就拥有被嵌套接口的所有方法了&lt;/li>
&lt;li>注意接口可能存在动态类型而值是nil，它本身并不与nil相等，它是存在动态类型的&lt;/li>
&lt;/ul>
&lt;h3 id="error接口">error接口&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> &lt;span style="color:#00688b;font-weight:bold">error&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008b45">Error&lt;/span>() &lt;span style="color:#00688b;font-weight:bold">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果要自定义error可以实现Error()方法，返回错误信息，打印error默认调用的是error.Error()&lt;/p>
&lt;p>errors包中的errors.New(&amp;ldquo;错误信息&amp;rdquo;)就是返回一个error对象&lt;/p>
&lt;h2 id="eface和iface">eface和iface&lt;/h2>
&lt;p>eface是interface{}的底层结构体，不包含任何方法，只有指向数据的指针和指向具体类型的指针&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">//iface:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span> iface &lt;span style="color:#8b008b;font-weight:bold">struct&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tab *itab &lt;span style="color:#228b22">//itab中不仅包括接口的类型，还包括指向具体类型的指针，还有方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> data unsafe.Pointer &lt;span style="color:#228b22">//指向数据的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="宕机panic和宕机恢复recover">宕机(panic)和宕机恢复(recover)&lt;/h2>
&lt;p>&lt;strong>Go语言没有异常系统，其使用 panic 触发宕机类似于其他语言的抛出异常（打印堆栈和信息），recover 的宕机恢复机制就对应其他语言中的 try/catch 机制。&lt;/strong>&lt;/p>
&lt;p>panic()和recover()都为内置函数，panic接收一个interface{}类型参数&lt;/p>
&lt;p>如果当前的 goroutine 陷入panic，调用 recover 可以捕获到 panic 的输入值，并且恢复正常的执行。&lt;/p>
&lt;p>&lt;strong>recover只能与defer搭配使用，用于恢复，相当于Java中的catch，try中发生错误，直接将控制交给catch&lt;/strong>&lt;/p>
&lt;p>e.g:&lt;/p>
&lt;p>web服务器崩溃时用recover关闭连接，或者向客户端传递异常信息用于调试&lt;/p>
&lt;h2 id="sort包">Sort包&lt;/h2>
&lt;h3 id="排序">排序&lt;/h3>
&lt;p>如果要对切片元素进行自定义排序，需要实现sort.Interface接口中的三个方法：&lt;/p>
&lt;ol>
&lt;li>​ Len() int // 获取元素数量&lt;/li>
&lt;li>​ Less(i, j int) bool // i，j是序列元素的指数。&lt;strong>即表示怎么样算一个元素小于另一个元素，由自己实现&lt;/strong>&lt;/li>
&lt;li>​ Swap(i, j int) // 交换元素&lt;/li>
&lt;/ol>
&lt;p>==注意，系统内置变量是不能够用来实现接口的，必须用type声明新类型==&lt;/p>
&lt;p>sort包中内置了一些切片，这些切片已经实现了Interface中的方法，&lt;strong>所以直接用这些切片定义，并用sort.Sort方法即可排序&lt;/strong>&lt;/p>
&lt;p>![image20201222154656587](file:///Users/chenzicong/Library/Application Support/typora-user-images/image-20201222154656587.png?msec=1657156704924)&lt;/p>
&lt;p>如果是针对于结构体想进行排序就要针对于某个字段写Less方法了&lt;/p>
&lt;p>&lt;strong>这里推荐sort包中更快的实现方式&lt;/strong>，==sort.Slice方法==，这样就不必实现sort.Interface中所有方法，直接提供一个切片和回调函数就行了（就是提供一个Less()函数，怎么比较切片中元素的大小）&lt;/p>
&lt;p>&lt;code>func Slice(slice interface{}, less func(i, j int) bool)&lt;/code>&lt;/p>
&lt;h3 id="查找">查找&lt;/h3>
&lt;p>sort.Search(n int, f func(i int) bool) int&lt;/p>
&lt;p>利用二分查找返回f(i)==true时最小的索引值，f是用户提供的回调函数，当[0,i)时f为false，&amp;gt;=i时f为true，通常是搜索array或者slice时使用，n传入len(arrry或者slice)&lt;/p>
&lt;h2 id="goroutine核心">goroutine（核心）&lt;/h2>
&lt;p>参考资料：&lt;a href="https://www.cnblogs.com/wdliu/p/9272220.html">go语言之行&amp;ndash;golang核武器goroutine调度原理、channel详解 - W-D - 博客园&lt;/a>&lt;/p>
&lt;p>&lt;strong>goroutine就是由go语言实现的用户级别线程，goroutine通过通道来相互传递消息&lt;/strong>&lt;/p>
&lt;p>&lt;strong>使用方法&lt;/strong>：&lt;/p>
&lt;p>&lt;strong>go 函数名(实参)即可运行一个goroutine&lt;/strong>&lt;/p>
&lt;h3 id="gmp模型">GMP模型&lt;/h3>
&lt;p>协程就是用户态线程，比内核态线程更加轻量，拥有自己的栈空间，程的切换由用户控制，切换开销小，线程的切换由操作系统控制，切换开销相对来说较大&lt;/p>
&lt;p>![image20210112164655231](file:///Users/chenzicong/Library/Application Support/typora-user-images/image-20210112164655231.png?msec=1657156704942)&lt;/p>
&lt;ul>
&lt;li>M:M代表操作系统级别的线程，由操作系统调度器管理，一个M对应一个P&lt;/li>
&lt;li>G:代表一个goroutine，表示待执行的任务，相当于==用户级别线程（协程）==，&lt;strong>切换开销小&lt;/strong>，新创建的G会先保存在P的本地队列（256长度的数组），如果本地队列存不下则会放到全局队列当中&lt;/li>
&lt;li>P:P全称是Processor，处理器，它的主要用途就是用来将M和G关联起来，所以它也维护了一个自己的&lt;strong>local goroutine队列&lt;/strong>，里面存储了所有需要它来执行的goroutine。当然还存在一个&lt;strong>全局的global goroutine队列&lt;/strong>，如果local队列中的goroutine运行完了也会取global队列中的goroutine来运行。P在go程序运行时就会创建，根据GOMAXPROCS来确定数量，默认是系统逻辑核数量&lt;/li>
&lt;li>Sched：&lt;strong>用户态级别调度器&lt;/strong>，负责将goroutine调度到具体某个队列中（可以是新的goroutine加入，或者是从其他队列中取得的goroutine(work stealing机制））&lt;/li>
&lt;/ul>
&lt;p>==GMP模型相对于GM模型有了P的本地队列，对于全局队列的锁竞争减少，有了work-stealing机制，有了对于M被goroutine系统调用阻塞的切换机制==&lt;/p>
&lt;p>如果直接在M上实现本地队列，一旦M被G阻塞，则M上的其他G也会被阻塞，而且M的数量会不断地增加&lt;/p>
&lt;h4 id="gmp流程">GMP流程&lt;/h4>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/oDialLqz4FKuyI1VJIxjfKOXYQzOn2FJRGVPmPNhwCC86SXciccZMy9StjzZSS7jswrUDAZQgpRqdHK4esQUYGicA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="图片">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>调用 go func()创建一个goroutine；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新创建的G优先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>M需要在P的本地队列弹出一个可执行的G，如果P的本地队列为空，则先会去全局队列中获取G，如果全局队列也为空则去其他P的本地队列中偷取G放到自己的队列当中（work-stealing)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>G将相关参数传输给M，为M执行G做准备&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当M执行某一个G时候如果发生了系统调用产生导致M会阻塞，如果当前P队列中有一些G，runtime会将线程M和P分离，&lt;strong>然后再获取空闲的线程或创建一个新的内核级的线程来服务于这个P&lt;/strong>，阻塞调用完成后G被销毁将值返回；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>销毁G，将执行结果返回&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当M系统调用结束时候，这个M会尝试获取一个空闲的P执行，如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="channel通道">channel通道&lt;/h3>
&lt;p>==channel本质上是一种有锁队列==，所以是并发安全的。发送和接收都遵循FIFO，发送使用&lt;code>ch &amp;lt;- 元素&lt;/code>，接收使用&lt;code>&amp;lt;- ch&lt;/code>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>无缓冲管道（同步）：&lt;/p>
&lt;p>ch := make(chan 类型)&lt;/p>
&lt;p>发送方向通道发送数据后，若没有接收方取数据就会阻塞，直到接收方接收为止；接收方同理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有缓冲管道（异步）：&lt;/p>
&lt;p>ch := make(chan 类型，缓冲区大小)&lt;/p>
&lt;p>不同于无缓冲的情况，发送方可以不用阻塞地一直向管道发送数据，直到缓冲区满之后才会阻塞（进入发送等待队列）；接收方也可以不用阻塞地从通道中取数据（当然是缓冲区中有数据的情况），直到没有数据可取为止，则接收方阻塞（进入接收等待队列）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>空结构体通道&lt;/strong>&lt;/p>
&lt;p>因为空结构体struct{}不占内存，所以可以用来作为信号来同步，当一个goroutine完成时，可以通过发送struct{}{}表示已完成，通知另一端的goroutine&lt;/p>
&lt;/li>
&lt;li>
&lt;p>单向通道&lt;/p>
&lt;p>&lt;strong>可以用在返回类型里，限定函数调用方的行为&lt;/strong>，双向通道赋值给单向通道可以自动转换&lt;/p>
&lt;ul>
&lt;li>只能发不能接类型：&lt;code>chan&amp;lt;-&lt;/code>&lt;/li>
&lt;li>只能接不能发类型：&lt;code>&amp;lt;-chan&lt;/code>，比如可以先定义一个双向通道往里面塞数据，然后返回单向通道，这种通道只能从里面读数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="关闭通道">关闭通道&lt;/h4>
&lt;p>使用原语close(chan)关闭通道，读取关闭的通道会读取到相应类型的&lt;strong>零值&lt;/strong>，如果继续向已关闭的channel发送数据会触发panic&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">go&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">func&lt;/span>(in &amp;lt;-&lt;span style="color:#8b008b;font-weight:bold">chan&lt;/span> &lt;span style="color:#00688b;font-weight:bold">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#228b22">// Using for-range to exit goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#228b22">// range has the ability to detect the close/end of a channel
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> x := &lt;span style="color:#8b008b;font-weight:bold">range&lt;/span> in {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#008b45">Printf&lt;/span>(&lt;span style="color:#cd5555">&amp;#34;Process %d\n&amp;#34;&lt;/span>, x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}(in)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">//range可以用来遍历通道，通道如果关闭了range会自动结束
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="tips">tips&lt;/h4>
&lt;ul>
&lt;li>注意发送到通道中的数据也经过了拷贝&lt;/li>
&lt;li>&lt;code>_,ok:=&amp;lt;-chan&lt;/code>从通道中读取数据的第二个boolean值可以判断通道是否已关闭&lt;/li>
&lt;/ul>
&lt;h2 id="sync包">Sync包&lt;/h2>
&lt;h3 id="syncwaitgroup">sync.WaitGroup&lt;/h3>
&lt;p>有时候主线程需要等待其他goroutine执行完毕，用time.Sleep的方法不太好，无法估计所有goroutine完成的时间，所以用sync.WaitGroup结构体来做同步比较好&lt;/p>
&lt;p>方法：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Add(delta int)&lt;/p>
&lt;p>delta表示要执行的goroutine数量，WaitGroup中的计数器+1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Done()&lt;/p>
&lt;p>sync.WaitGroup变量调用一次Done()，结构体中的计数器（delta数）就-1（实际上是向Add方法传入了负数）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Wait()&lt;/p>
&lt;p>一直阻塞，直到计数器变为0为止，可以放在main函数的最后，等待所有其他goroutine done，然后结束程序&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="互斥锁和读写互斥锁">互斥锁和读写互斥锁&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>互斥锁&lt;/p>
&lt;p>sync.Mutex，对等操作系统里学的mutex&lt;/p>
&lt;ul>
&lt;li>可以使用defer mu.Unlock()避免忘记解锁&lt;/li>
&lt;li>避免重复锁定或解锁&lt;/li>
&lt;li>当前goroutine如果不能获取到锁（被其他goroutine持有），则可能会进入自旋状态（进入自旋状态的条件比较苛刻）&lt;/li>
&lt;li>如果goroutine对锁的等待时间超过1ms，互斥锁会从正常模式进入饥饿模式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>读写互斥锁&lt;/p>
&lt;p>sync.RWMutex，封装了Mutex，还内置读者计数器，可用于单写者多读者，效率比普通互斥锁要高&lt;/p>
&lt;ul>
&lt;li>可以多次调用读锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="synconce">sync.Once&lt;/h3>
&lt;p>sync.Once.Do接收一个无参函数，只执行一次该函数，该结构体有个字段done表示是否已执行过该函数&lt;/p>
&lt;h3 id="synccond">sync.Cond&lt;/h3>
&lt;p>sync.Cond需要传入一个锁来发生作用，作用在于，可以避免goroutine长时间由于for循环监听变量状态变化而占据资源，当状态不满足时可以先进行等待（形成goroutine等待链），等待其他goroutine唤醒&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Wait()休眠并等待被唤醒，加入goroutine等待链中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Signal()唤醒等待链最前面的goroutine&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Broadcast()唤醒等待链中所有的goroutine&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="syncatomic包">sync/atomic包&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>原子操作即是进行过程中不能被中断的操作，针对某个值的原子操作在被进行的过程中，CPU绝不会再去进行其他的针对该值的操作。为了实现这样的严谨性，原子操作仅会由一个独立的CPU指令代表和完成。原子操作是无锁的，常常直接通过CPU指令直接实现。 事实上，其它同步技术的实现常常依赖于原子操作。&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>即使代码在加了锁的临界区中运行也有可能会被系统中断，比如发生上下文切换，所以需要原子操作防止被中断。==也可以用来保护共享变量，如基本类型==&lt;/p>
&lt;p>&lt;strong>原子操作有：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>加法（add）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>比较并交换（compare and swap，简称 CAS）&lt;/p>
&lt;p>&lt;strong>CAS可以进行无锁编程，做到在没有变量被阻塞的情况下实现变量的同步，所以也叫非阻塞同步&lt;/strong>&lt;/p>
&lt;p>CAS有点像乐观锁，将期望old值与当前值比较，如果相同就赋new值，并且返回true；否则不赋值，并且返回false&lt;/p>
&lt;p>乐观锁适用于==多读==场景，总是认为别人没有修改数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>加载（load）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>存储（store）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>交换（swap）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="syncmap">sync.Map&lt;/h3>
&lt;p>并发安全map，适用于读多写少的场景，其涵盖两个字典，一个是atomic.Value的只读字典，一个是普通脏字典。读时无需调用锁，但写时需要锁。&lt;/p>
&lt;h2 id="反射">反射&lt;/h2>
&lt;p>参考：&lt;a href="https://www.cnblogs.com/qcrao-2018/p/10822655.html">深度解密Go语言之反射 - Stefno - 博客园&lt;/a>&lt;/p>
&lt;p>主要函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">TypeOf&lt;/span> ( i &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span>{} ) Type
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">ValueOf&lt;/span> ( i &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span>{} ) Value
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">func&lt;/span> &lt;span style="color:#008b45">DeepEqual&lt;/span>(x, y &lt;span style="color:#8b008b;font-weight:bold">interface&lt;/span>{}) &lt;span style="color:#00688b;font-weight:bold">bool&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Type 是一个接口，定义了很多相关方法，用于获取类型信息。（返回的实际上是rtype，rtype与_type基本一致，实现了Type接口）&lt;/li>
&lt;li>Value是一个结构体，既保存了类型信息也保存了类型值（类似eface），里面保存了rtype也保存了指向实体的指针&lt;/li>
&lt;li>Type，Value，interface之间可以相互转换&lt;/li>
&lt;li>DeepEqual用于比较两个变量是否“深度”相等，可以用于比较复杂的类型，简单的类型当然自己实现肯定是效率更高的（比如结构体之间比较要如何算相等），反射比较费时，但是比较复杂的可以通过DeepEqual进行比较。&lt;strong>两个interface是可以用DeepEqual来进行对比的，即比较两者的实体是否相等&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="context">Context&lt;/h2>
&lt;p>参考：&lt;a href="https://www.cnblogs.com/qcrao-2018/p/11007503.html">深度解密Go语言之context - Stefno - 博客园&lt;/a>&lt;/p>
&lt;p>通常Http server每来一个请求都会启动多个goroutine来服务这个请求，有的goroutine去下游获取数据，有的goroutine去数据库拿数据，形成多个goroutine组成的树。如果有的下游服务响应速度较慢，而又没有超时控制机制，会导致等待的goroutine越来越多。可以通过context设置超时时间，超过超时时间，所有goroutine&lt;strong>快速退出，回收资源&lt;/strong>。&lt;/p>
&lt;p>context用于goroutine组成的树中==同步取消信号==以减少资源消耗，==或者传递请求ID和用户认证token==&lt;/p>
&lt;h4 id="常用方法">常用方法&lt;/h4>
&lt;p>这些方法通常第一个参数传入一个父context，会返回一个子context和cancel函数，如果提前调用cancel函数，WithTimeout会关掉定时器&lt;/p>
&lt;ol>
&lt;li>
&lt;p>WithCancel(parant Context)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>WithTimeout(parent Context,timeout time.Duration)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>WithDeadline(parent Context,d time.Time)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Tips:
&lt;ul>
&lt;li>如果Context已经被取消，可以从当前context的Done()方法中读取出相应的零值，表示channel已经被关闭&lt;/li>
&lt;li>如果父Context被取消，是递归取消的，子Context的done通道都会被关闭，都可从Done()方法中读取出相应的零值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="内存分配">内存分配&lt;/h2>
&lt;p>引用：https://zhuanlan.zhihu.com/p/59125443&lt;/p>
&lt;p>GO内存分配采用TCMalloc的机制，使用多级缓存：线程缓存，中心缓存和页堆，并根据对象的大小采取不同的内存分配策略。每个线程都会分配一个线程缓存（runtime.mcache)进行微小对象的分配，线程缓存持有一定数量的不同种类的runtime.mspan（==内存管理单元==），mspan负责一定数量内存页的分配和回收，mspan会根据跨度类来决定所能存储的对象大小和数量（决定特定大小的对象的分配），&lt;strong>内存分配时，先确定分配对象的大小和跨度类，然后根据跨度类确定mspan，然后由mspan来找是否有空闲的对象可供分配&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-38c31cf60d1514beb5be81d465ea36af_1440w.jpg" alt="img">&lt;/p>
&lt;p>&lt;strong>每个线程持有线程缓存可以避免锁竞争单来的内存分配性能影响&lt;/strong>。当线程缓存不能满足小对象的分配时，会去中心缓存补充runtime.mspan，每个mcentral保存一种mspan列表，当中心缓存也无法满足对象的分配时，会去页堆申请mspan用于切割成小对象。大对象由页堆直接分配。&lt;/p>
&lt;p>大体上的分配流程：&lt;/p>
&lt;ul>
&lt;li>32KB 的对象，直接从mheap上分配；&lt;/li>
&lt;li>&amp;lt;=16B 的对象使用mcache的tiny分配器分配；&lt;/li>
&lt;li>(16B,32KB] 的对象，首先计算对象的规格大小，然后使用mcache中相应规格大小的mspan分配；&lt;/li>
&lt;li>如果mcache没有相应规格大小的mspan，则向mcentral申请&lt;/li>
&lt;li>如果mcentral没有相应规格大小的mspan，则向mheap申请&lt;/li>
&lt;li>如果mheap中也没有合适大小的mspan，则向操作系统申请&lt;/li>
&lt;/ul>
&lt;h2 id="垃圾收集">垃圾收集&lt;/h2>
&lt;p>三色标记法（基础，用于标记和清除对象），并发回收（尽可能减小暂停程序带来的性能影响），混合写屏障（避免因并发改动指针而引发的错误的垃圾回收）&lt;/p>
&lt;h3 id="触发时机">触发时机&lt;/h3>
&lt;ol>
&lt;li>用户通过runtime.GC()函数手动触发&lt;/li>
&lt;li>后台定时检查，超过一定时间仍没有触发则会触发，默认设置2分钟&lt;/li>
&lt;li>堆内存到达一定比例时触发，默认是上次垃圾回收时堆内存大小的2倍&lt;/li>
&lt;li>线程缓存中内存管理单元不足时，申请分配大对象时&lt;/li>
&lt;/ol>
- https://jessestutler.github.io/posts/golang%E5%9F%BA%E7%A1%80/ - 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Docker底层原理</title><link>https://jessestutler.github.io/posts/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</link><pubDate>Sun, 07 Mar 2021 11:12:39 +0800</pubDate><guid>https://jessestutler.github.io/posts/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</guid><description>Jesse's Blog https://jessestutler.github.io/posts/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ -&lt;h1 id="docker底层原理">docker底层原理&lt;/h1>
&lt;h2 id="namespace资源隔离">namespace——资源隔离&lt;/h2>
&lt;p>namespace 是 Linux 内核用来隔离内核资源的方式，同一个namespace中的进程之间可以互相感知，不同namespace之间的进程是相互独立的，&lt;strong>docker本身就是一个进程，通过namespace来实现隔离，从而模拟独立运行环境&lt;/strong>，在/proc/$$/ns下能查看当前进程下的所有link文件，每个link文件对应不同的namespace，&lt;strong>如果不同的进程间有相同的namespace的inode号，则他们是共享namespace的&lt;/strong>，否则他们属于不同的的namespace&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gob6e80y1pj30i904dglp.jpg" alt="img">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>*&lt;em>通过clone()函数在创建子进程的同时给子进程创建新的namespace（传入CLONE_&lt;em>宏定义）&lt;/em>&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>UTS namespace：&lt;/p>
&lt;p>提供&lt;strong>主机名和域名&lt;/strong>的隔离，使容器能够通过服务名访问&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IPC namespace（进程间通信）：&lt;/p>
&lt;p>实现&lt;strong>信号量、消息队列和共享内存等资源&lt;/strong>的隔离&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PID namespace：&lt;/p>
&lt;p>对进程内的PID重新标号，从1开始，每个PID namespace都有自己的计数程序，宿主机的PID namespace相当于创建进程的PID namespace的parent pid namespace，能看到子节点（child pid namespace)中的内容，但子节点不能看到父节点当中的内容，这样父节点能在外部管理容器内的进程&lt;/p>
&lt;p>如果pid namespace中的某个进程的父进程被杀死，该进程成为孤儿进程，则&lt;strong>会被当前pid namespace的init进程（pid为1，如/bin/bash）收养，成为其子进程&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mount namespace:&lt;/p>
&lt;p>通过隔离文件系统挂载点来隔离文件系统（当创建新的mount namespace时，会将所有挂载点复制给子进程，但在这之后，子进程对自己namespace内文件系统进行的操作不会影响到父进程namespace）&lt;/p>
&lt;p>&lt;strong>可以通过共享挂载机制传播挂载（主从挂载、共享挂载等）&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>network namespace:&lt;/p>
&lt;p>提供网络资源的隔离，包括网络设备、协议栈、路由表、防火墙等等&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://images2018.cnblogs.com/blog/1259802/201804/1259802-20180410165500455-232801094.jpg" alt="img">&lt;/p>
&lt;p>&lt;strong>默认的bridge模式&lt;/strong>：&lt;/p>
&lt;p>每个容器有独立的network namespace，宿主机通过docker0网桥（虚拟网桥）来连接不同的network namespace，容器通过veth pair（虚拟以太网端口对，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来）连接docker0网桥，设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名。&lt;/p>
&lt;p>如果容器想主动和外界通信，或者外界想访问容器内的服务（访问宿主机的端口），实际上这是通过iptables来管理的（进行了转发和NAT转换等操作）&lt;/p>
&lt;p>&lt;strong>host模式：&lt;/strong>&lt;/p>
&lt;p>容器和宿主机共享network namespace，但其他namespace与宿主机隔离，容器用的是宿主机的ip与外界通信，性能较好但易产生端口冲突&lt;/p>
&lt;p>&lt;strong>container模式：&lt;/strong>&lt;/p>
&lt;p>新创建的容器若指定container模式，则和已经存在的容器共享一个network namespace，与此容器共享ip和协议栈&lt;/p>
&lt;ul>
&lt;li>
&lt;p>user namespace&lt;/p>
&lt;p>提供安全隔离，比如用户id，用户组，权限等，在子进程的user namespace中拥有新的用户和用户组，在父进程中的普通用户可能却成为子进程中namespace的超级用户，结构与pid namespace类似（树状结构），&lt;strong>子user namespace中的用户和用户组需要与父user namespace中的用户和用户组相对应（做映射）&lt;/strong>，这样这个user namespace才能与其他user namespace中的进程通信，甚至访问共享的文件（即对应到其他user namespace的用户和用户组并拥有相应的权限，如果没有相应的权限就不能在其他user namespace执行某些操作）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="cgroups资源限制">cgroups——资源限制&lt;/h2>
&lt;p>cgroups 是Linux内核提供的一种&lt;strong>可以限制单个进程或者多个进程所使用资源&lt;/strong>的机制，可以对 cpu，内存等资源实现精细化的控制（使用上限，使用范围等等），cgroup通过伪文件系统的形式进行控制&lt;/p>
&lt;p>&lt;strong>涉及概念：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>task（任务）：表示系统的一个进程或线程&lt;/p>
&lt;/li>
&lt;li>
&lt;p>subsystem(子系统)：每个子系统就是一个资源控制器，有cpu、memory、io等等，/sys/fs/cgroup/下的目录就代表每个子系统&lt;/p>
&lt;/li>
&lt;li>
&lt;p>hierarchy（层级）：层级由一系列的cgroup以一个树状形式组成，由一个或多个子系统限制层级的资源使用量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>cgroup&lt;/strong>（控制组）：核心概念，由cgroup组成层级，task放在cgroup中，从而控制进程的使用资源量，docker的实现方法就是在每个子系统中为每个容器创建cgroup&lt;/p>
&lt;p>ps:笔者自己ipad画的图，有点简陋抱歉:P，以后文章的图有时间都会用Graffle好好画一下&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8pmb9h1aj30xg0pdq97.jpg" alt="image-20201104214438717">&lt;/p>
&lt;h2 id="docker-架构总览">docker 架构总览&lt;/h2>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gob68s57bpj311c0hm7ax.jpg" alt="image-20201209104859776">&lt;/p>
&lt;h3 id="runc">runC&lt;/h3>
&lt;p>是对于OCI标准的一个参考实现，是一个可以用于创建和运行容器的CLI(command-line interface)工具。runc直接与容器所依赖的cgroup/linux kernel等进行交互，负责为容器配置cgroup/namespace等启动容器所需的环境，创建启动容器的相关进程。runC基本上就是一个命令行小工具，它可以不用通过Docker引擎，直接就可以创建容器。这是一个独立的二进制文件，使用OCI容器就可以运行它。&lt;/p>
&lt;h3 id="containerd">containerd&lt;/h3>
&lt;p>containerd 是一个守护进程，它可以使用runC管理容器，并使用gRPC暴露容器的其他功能。docker engine面向client，containerd暴露出针对容器的增删改查的接口，Docker engine通过gRPC调用这些接口完成对于容器的操作，containerd最后会通过runc来实际运行容器。&lt;/p>
&lt;h3 id="containerd-shim">containerd-shim&lt;/h3>
&lt;p>containerd-shim称之为垫片，它使用runC命令行工具完成容器的启动、停止以及容器运行状态的监控。containerd-shim进程由containerd进程拉起，并持续存在到容器实例进程退出为止（和容器进程同生命周期）。这种设计的优点是，只要是符合OCI规范的容器，都可以通过containerd-shim来进行调用&lt;/p>
&lt;h2 id="联合文件系统">联合文件系统&lt;/h2>
&lt;p>&lt;img src="https://docs.docker.com/storage/storagedriver/images/container-layers.jpg" alt="Layers of a container based on the Ubuntu image">&lt;/p>
&lt;p>&lt;strong>如果容器基于同一镜像构建，所有容器共享底部的镜像层，镜像层是read-only的，不可被修改，容器只是在镜像层之上创建了一个读写层，所有容器的修改都是在读写层当中修改，并不会影响到底部的镜像层，当容器删除了，读写层也就跟着删除了（除非commit做成了新的镜像）&lt;/strong>&lt;/p>
&lt;p>&lt;strong>就算容器不是基于同一镜像构建，如果不同镜像中有相同的层（比如FROM是相同的），容器也会读取同一镜像层，这就是联合文件系统的精髓所在，副本只保存一份&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://docs.docker.com/storage/storagedriver/images/sharing-layers.jpg" alt="Containers sharing same image">&lt;/p>
&lt;h2 id="copy-on-writecow机制">Copy on write（COW）机制&lt;/h2>
&lt;p>&lt;strong>当容器需要读取文件的时候&lt;/strong>&lt;/p>
&lt;p>从最上层镜像开始查找，往下找，找到文件后读取并放入内存，若已经在内存中了，直接使用。(即，同一台机器上运行的docker容器共享运行时相同的文件)。&lt;/p>
&lt;p>&lt;strong>当容器需要添加文件的时候&lt;/strong>&lt;/p>
&lt;p>直接在最上面的容器层可写层添加文件，不会影响镜像层。&lt;/p>
&lt;p>&lt;strong>当容器需要修改文件的时候&lt;/strong>&lt;/p>
&lt;p>从上往下层寻找文件，找到后，&lt;strong>复制到容器可写层&lt;/strong>，然后，对容器来说，可以看到的是容器层的这个文件，看不到镜像层里的文件。容器在容器层修改这个文件（也就是覆盖）。&lt;/p>
&lt;p>&lt;strong>如果是一个经常需要写的应用，最好使用volume而不是都写在容器层里，这样不会使容器层变得很大&lt;/strong>&lt;/p>
&lt;p>&lt;strong>当容器需要删除文件的时候&lt;/strong>&lt;/p>
&lt;p>从上往下层寻找文件，找到后在容器中记录删除。即，&lt;strong>并不会真正的删除文件，而是软删除&lt;/strong>。这将导致镜像体积只会增加，不会减少。&lt;strong>所以要写Dockerfile时如果要删除镜像中的文件，最好在同一层删除，否则只是软删除&lt;/strong>（因为如果真正的删除就会导致基于这个镜像构架内的其他容器无法再读取这个文件了）&lt;/p>
&lt;h2 id="iptables默认规则只列举了部分">iptables默认规则（只列举了部分）&lt;/h2>
&lt;ul>
&lt;li>nat表：
&lt;ul>
&lt;li>如果数据源地址是docker0网段地址，且发往除docker 0外端口（即发往主机外），则做SNAT转换，修改为主机网卡ip地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>filter表：
&lt;ul>
&lt;li>docker0发出的包可以中转给docker 0本身，即容器之间可以互相通信&lt;/li>
&lt;li>docker0发出的包可以中转给其他宿主机上的其他网卡&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>《Docker容器与容器云 第2版》浙江大学SEL实验室·著&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/517e757d6d17">https://www.jianshu.com/p/517e757d6d17&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/sparkdev/tag/docker/default.html?page=1">https://www.cnblogs.com/sparkdev/tag/docker/default.html?page=1&lt;/a>&lt;/li>
&lt;/ul>
- https://jessestutler.github.io/posts/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ - 本站遵循 CC-BY-NC 4.0 协议</description></item></channel></rss>