<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>k8s on Jesse's Blog</title><link>https://jessestutler.github.io/categories/k8s/</link><description>Recent content in k8s on Jesse's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Thu, 10 Jun 2021 14:51:48 +0800</lastBuildDate><atom:link href="https://jessestutler.github.io/categories/k8s/index.xml" rel="self" type="application/rss+xml"/><item><title>K8s Iptables分析</title><link>https://jessestutler.github.io/posts/k8s-iptables%E5%88%86%E6%9E%90/</link><pubDate>Thu, 10 Jun 2021 14:51:48 +0800</pubDate><guid>https://jessestutler.github.io/posts/k8s-iptables%E5%88%86%E6%9E%90/</guid><description>K8s iptables分析 笔者最近因为需要看了下k8s的kube-proxy在默认iptables模式下对于iptables规则是如何管理的，以此作为记录并分享，后面会继续跟进kube-proxy并进行源码分析
这里笔者分享一套还不错的iptables学习路线：
https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables
iptables知识 查 -t [表名] 指定想查看的表的规则，默认为filter表
-L [链名] 指定想查看的某个表在某个链当中的规则，不写链列出表在所有链当中的规则
-v 列出详细规则
-n 不做域名解析，直接显示ip（通常-nvL同行）
&amp;ndash;line-number 显示行数
e.g:
iptables -t nat -L INPUT
列出nat表在INPUT链中的所有规则
增 -I [链名] 插入规则到指定的链当中（在链的首部插入）
-I [链名] [序号] 插入规则到指定的链当中（指定是链的第几条规则）
-A [链名] 插入规则到指定的链当中（在链的尾部插入）
-s [源地址,[源地址]&amp;hellip;] 或[源地址网段]
-d [目标地址]
用!在-s或-d前表示取反，非地址匹配
&amp;ndash;sport 源端口
&amp;ndash;dport 目标端口
&amp;ndash;sport/dport [起始端口:结束端口] 表示匹配此范围内端口
指定源端口和目标端口为扩展匹配条件，-m用来指定扩展模块，如-m tcp -dport 22表示匹配ssh，若不指定-m（最好指定），默认与-p指定的协议相同
-m [模块] 使用模块扩展匹配条件
离散端口： -m multiport --dports 22,53,80 需要指定multiport模块用来离散匹配 范围ip： -m iprange --src-range 192.</description></item><item><title>kubectl常用命令</title><link>https://jessestutler.github.io/posts/kubectl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 07 Mar 2021 10:30:17 +0800</pubDate><guid>https://jessestutler.github.io/posts/kubectl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>k8s命令 引言 本文列举了一些kubectl的常用命令以及其对应的常用参数
kubectl的详细信息可参照：https://kubernetes.io/docs/reference/kubectl/overview/
如果熟悉了kubectl的朋友，对于经常性的kubectl get 和kubectl describe查找resource感到繁琐，笔者在这里推荐一款开源的增强型kubectl软件k9s：https://github.com/derailed/k9s，相信对于vim熟悉的朋友会喜欢这款开源软件，而且可以当简略的dashboard使用
kubectl kubectl create -f [yaml或者json文件]
通过yaml或者json文件创建一个组件
-n 指定命名空间，如果不指定，默认是在default命名空间下，其他命令也一样
kubectl get [组件] [组件名]
获取组件的基本信息，如果想获取详细信息用kubectl describe
-o wide 显示更多信息，-o yaml 以yaml格式显示组件信息
&amp;ndash;show-labels 多显示标签
-l 标签键=值 根据标签来筛选出pod基本信息，多个键值对用逗号分隔
-L [标签名] 多显示指定标签名的标签列，多个标签用逗号分隔
&amp;ndash;all-namespaces 列出所有命名空间的组件
kubectl logs [podname]
查看pod内容器的日志输出，如果只有一个容器不用指定容器名，如果有多个容器，想查看指定容器的日志需要-c参数指定
kubectl label [组件] [组件名] key=value [--overwrite]
修改或添加组件的标签，用key=value形式，如果要复写之前的标签，需要多加一个&amp;ndash;overwrite
如果要删除之前的标签，直接在key后跟一个减号即可（即key-）
kubectl delete [组件] [组件名1] [组件名2] [...]
删除组件
-all 删除所有组件
注：删除命名空间，里面的组件也会一并删除
kubectl scale [组件] [组件名] --replicas</description></item><item><title>K8s Resource概析</title><link>https://jessestutler.github.io/posts/k8s-resource%E6%A6%82%E6%9E%90/</link><pubDate>Sun, 07 Mar 2021 10:20:30 +0800</pubDate><guid>https://jessestutler.github.io/posts/k8s-resource%E6%A6%82%E6%9E%90/</guid><description>K8s Resource概析 引言 本文参照《Kubernetes in Action中文版》及其一些网上资料，对K8s中基础的Resource进行了概析。本文会持续更新。
pod 为什么需要pod?
主要目的是由多个进程组成的一个应用程序，多个进程不能聚集在一个容器中运行**（容器的设计目的就是只运行一个进程，如果容器中运行多个不相关的进程，比如需要包含一种进程崩溃后能够重启的机制，同时将进程的活动记录记录到相同的标准输出中，我们很难确定每个进程分别记录了什么），我们用pod来封装容器，将其作为k8s的基本单位**，既可以做到一个进程单独运行于一个容器当中，容器之间相互隔离，保持了容器的特性，又能同时运行一些密切相关的进程，为他们提供相同的环境。
pod中的容器共享network namespace，容器中运行的进程之间能够通过端口来相互通信（同一个pod中的容器拥有相同的loopback网路接口，可以通过发往localhost与其他容器中的进程相互通信）
如何决定多个容器是否要放入同一个pod中？ 它们需要一起运行还是可以在不同主机上运行 它们代表的是一个整体还是相互独立的组件 它们必须一起扩缩容还是可以分别进行 liveness probe &amp;amp; readiness probe liveness probe——存活探针（在pod running时检测）
通过 TCP、HTTP 或者命令行方式对应用就绪进行检测。对于 HTTP 类型探针，Kubernetes 会定时访问该地址，如果该地址的返回码不在 200 到 400 之间，则认为该容器不健康，会杀死该容器重建新的容器。
readiness probe——就绪探针（在pod就绪前检测）
对于启动缓慢的应用，为了避免在应用启动完成之前将流量导入。Kubernetes 支持业务容器提供一个 readiness 探针，对于 HTTP 类型探针，Kubernetes 会定时访问该地址，如果该地址的返回码不在 200 到 400 之间，则认为该容器无法对外提供服务，不会把请求调度到该容器。
容器重启策略 Always ： 容器失效时，kubelet 自动重启该容器（就算成功执行完容器也会重启） OnFailure ： 容器终止运行且退出码不为0时重启 Never ： 不论状态为何， kubelet 都不重启该容器 节点亲和性 nodeAffinity:</description></item></channel></rss>